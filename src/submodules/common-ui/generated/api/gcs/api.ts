/* tslint:disable */
/* eslint-disable */
/**
 * Articles API
 * API for global content
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActionAnswer
 */
export interface ActionAnswer {
    /**
     * 
     * @type {number}
     * @memberof ActionAnswer
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ActionAnswer
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof ActionAnswer
     */
    'locationId': number;
    /**
     * 
     * @type {string}
     * @memberof ActionAnswer
     */
    'answer': string;
    /**
     * 
     * @type {boolean}
     * @memberof ActionAnswer
     */
    'correct': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ActionAnswer
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActionAnswer
     */
    'revertedAt': string | null;
    /**
     * 
     * @type {number}
     * @memberof ActionAnswer
     */
    'revertedBy': number | null;
}
/**
 * 
 * @export
 * @interface ActionAnswerPage
 */
export interface ActionAnswerPage {
    /**
     * 
     * @type {ActionAnswerPageMeta}
     * @memberof ActionAnswerPage
     */
    'meta': ActionAnswerPageMeta;
    /**
     * 
     * @type {Array<ActionAnswer>}
     * @memberof ActionAnswerPage
     */
    'data': Array<ActionAnswer>;
}
/**
 * 
 * @export
 * @interface ActionAnswerPageMeta
 */
export interface ActionAnswerPageMeta {
    /**
     * 
     * @type {number}
     * @memberof ActionAnswerPageMeta
     */
    'perPage': number;
    /**
     * 
     * @type {number}
     * @memberof ActionAnswerPageMeta
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof ActionAnswerPageMeta
     */
    'lastPage': number;
    /**
     * 
     * @type {number}
     * @memberof ActionAnswerPageMeta
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof ActionAnswerPageMeta
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof ActionAnswerPageMeta
     */
    'to': number;
}
/**
 * 
 * @export
 * @interface ActionVariants
 */
export interface ActionVariants {
    [key: string]: ActionVariantsValue;

}
/**
 * 
 * @export
 * @interface ActionVariantsValue
 */
export interface ActionVariantsValue {
    /**
     * 
     * @type {string}
     * @memberof ActionVariantsValue
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ActionVariantsValue
     */
    'translationStatus': ActionVariantsValueTranslationStatusEnum;
}

export const ActionVariantsValueTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ActionVariantsValueTranslationStatusEnum = typeof ActionVariantsValueTranslationStatusEnum[keyof typeof ActionVariantsValueTranslationStatusEnum];

/**
 * 
 * @export
 * @interface ActionVariantsValueAnyOf
 */
export interface ActionVariantsValueAnyOf {
    /**
     * 
     * @type {string}
     * @memberof ActionVariantsValueAnyOf
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ActionVariantsValueAnyOf
     */
    'translationStatus': ActionVariantsValueAnyOfTranslationStatusEnum;
}

export const ActionVariantsValueAnyOfTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ActionVariantsValueAnyOfTranslationStatusEnum = typeof ActionVariantsValueAnyOfTranslationStatusEnum[keyof typeof ActionVariantsValueAnyOfTranslationStatusEnum];

/**
 * 
 * @export
 * @interface ArchiveArticlesRequest
 */
export interface ArchiveArticlesRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof ArchiveArticlesRequest
     */
    'articleIds': Array<number>;
}
/**
 * 
 * @export
 * @interface ArchiveArticlesResponse
 */
export interface ArchiveArticlesResponse extends Array<Article> {
}
/**
 * 
 * @export
 * @interface Article
 */
export interface Article {
    /**
     * 
     * @type {number}
     * @memberof Article
     */
    'id': number;
    /**
     * 
     * @type {ArticleVariantsGet}
     * @memberof Article
     */
    'variants': ArticleVariantsGet;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    'status': ArticleStatusEnum;
    /**
     * 
     * @type {AudienceIds}
     * @memberof Article
     */
    'audiences': AudienceIds;
    /**
     * 
     * @type {LanguageList}
     * @memberof Article
     */
    'languages': LanguageList;
    /**
     * 
     * @type {Array<ArticleAudiencesResourcesInner>}
     * @memberof Article
     */
    'audiencesResources'?: Array<ArticleAudiencesResourcesInner>;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    'sharingComment'?: string | null;
    /**
     * 
     * @type {ArticleChannel}
     * @memberof Article
     */
    'channel': ArticleChannel | null;
    /**
     * 
     * @type {number}
     * @memberof Article
     */
    'createdBy'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    'publishAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    'updatedAt': string;
    /**
     * 
     * @type {ArticleOriginalTenant}
     * @memberof Article
     */
    'originalTenant': ArticleOriginalTenant | null;
    /**
     * 
     * @type {number}
     * @memberof Article
     */
    'seen': number;
    /**
     * 
     * @type {Array<Block>}
     * @memberof Article
     */
    'blocks': Array<Block>;
    /**
     * 
     * @type {ArticleCollaborators}
     * @memberof Article
     */
    'users': ArticleCollaborators;
}

export const ArticleStatusEnum = {
    Draft: 'draft',
    Published: 'published',
    Archived: 'archived',
    Inbound: 'inbound',
    Rejected: 'rejected'
} as const;

export type ArticleStatusEnum = typeof ArticleStatusEnum[keyof typeof ArticleStatusEnum];

/**
 * 
 * @export
 * @interface ArticleAudiencesResourcesInner
 */
export interface ArticleAudiencesResourcesInner {
    /**
     * 
     * @type {number}
     * @memberof ArticleAudiencesResourcesInner
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ArticleAudiencesResourcesInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ArticleChange
 */
export interface ArticleChange {
    /**
     * 
     * @type {ArticleChangeVariants}
     * @memberof ArticleChange
     */
    'variants'?: ArticleChangeVariants;
    /**
     * 
     * @type {ArticleChangeBlocks}
     * @memberof ArticleChange
     */
    'blocks'?: ArticleChangeBlocks;
    /**
     * 
     * @type {ArticleChangeLanguages}
     * @memberof ArticleChange
     */
    'languages'?: ArticleChangeLanguages;
    /**
     * 
     * @type {ArticleChangeAudiences}
     * @memberof ArticleChange
     */
    'audiences'?: ArticleChangeAudiences;
    /**
     * 
     * @type {ArticleChangeUsers}
     * @memberof ArticleChange
     */
    'users'?: ArticleChangeUsers;
    /**
     * 
     * @type {ArticleChangePublishAt}
     * @memberof ArticleChange
     */
    'publishAt'?: ArticleChangePublishAt;
    /**
     * 
     * @type {ArticleChangeStatus}
     * @memberof ArticleChange
     */
    'status'?: ArticleChangeStatus;
    /**
     * 
     * @type {ArticleChangeChannelId}
     * @memberof ArticleChange
     */
    'channelId'?: ArticleChangeChannelId;
}
/**
 * 
 * @export
 * @interface ArticleChangeAudiences
 */
export interface ArticleChangeAudiences {
    /**
     * 
     * @type {Array<number>}
     * @memberof ArticleChangeAudiences
     */
    'added': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ArticleChangeAudiences
     */
    'removed': Array<number>;
}
/**
 * 
 * @export
 * @interface ArticleChangeBlocks
 */
export interface ArticleChangeBlocks {
    /**
     * 
     * @type {Array<ArticleChangeBlocksAddedInner>}
     * @memberof ArticleChangeBlocks
     */
    'added': Array<ArticleChangeBlocksAddedInner> | null;
    /**
     * 
     * @type {Array<ArticleChangeBlocksAddedInner>}
     * @memberof ArticleChangeBlocks
     */
    'removed': Array<ArticleChangeBlocksAddedInner> | null;
    /**
     * 
     * @type {Array<ArticleChangeBlocksChangedInner>}
     * @memberof ArticleChangeBlocks
     */
    'changed': Array<ArticleChangeBlocksChangedInner>;
}
/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInner
 */
export interface ArticleChangeBlocksAddedInner {
    /**
     * 
     * @type {number}
     * @memberof ArticleChangeBlocksAddedInner
     */
    'id': number;
    /**
     * 
     * @type {{ [key: string]: ArticleChangeBlocksAddedInnerVariantsValue; }}
     * @memberof ArticleChangeBlocksAddedInner
     */
    'variants': { [key: string]: ArticleChangeBlocksAddedInnerVariantsValue; };
    /**
     * 
     * @type {number}
     * @memberof ArticleChangeBlocksAddedInner
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInner
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValue
 */
export interface ArticleChangeBlocksAddedInnerVariantsValue {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValue
     */
    'translationStatus': ArticleChangeBlocksAddedInnerVariantsValueTranslationStatusEnum;
    /**
     * 
     * @type {Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInner>}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValue
     */
    'items': Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInner>;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValue
     */
    'type': ArticleChangeBlocksAddedInnerVariantsValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValue
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValue
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValue
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValue
     */
    'tenantId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValue
     */
    'openIn': ArticleChangeBlocksAddedInnerVariantsValueOpenInEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValue
     */
    'description': string;
}

export const ArticleChangeBlocksAddedInnerVariantsValueTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueTranslationStatusEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueTranslationStatusEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueTranslationStatusEnum];
export const ArticleChangeBlocksAddedInnerVariantsValueTypeEnum = {
    Internal: 'internal'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueTypeEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueTypeEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueTypeEnum];
export const ArticleChangeBlocksAddedInnerVariantsValueOpenInEnum = {
    CurrentWindow: 'current-window',
    NewWindow: 'new-window'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueOpenInEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueOpenInEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueOpenInEnum];

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOf
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOf {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf
     */
    'translationStatus': ArticleChangeBlocksAddedInnerVariantsValueAnyOfTranslationStatusEnum;
    /**
     * 
     * @type {Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInner>}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf
     */
    'items': Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInner>;
}

export const ArticleChangeBlocksAddedInnerVariantsValueAnyOfTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOfTranslationStatusEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfTranslationStatusEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfTranslationStatusEnum];

/**
 * @type ArticleChangeBlocksAddedInnerVariantsValueAnyOf1
 * @export
 */
export type ArticleChangeBlocksAddedInnerVariantsValueAnyOf1 = ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf | ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1;

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf
     */
    'type': ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf
     */
    'translationStatus': ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOfTranslationStatusEnum;
}

export const ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOfTypeEnum = {
    External: 'external'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOfTypeEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOfTypeEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOfTypeEnum];
export const ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOfTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOfTranslationStatusEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOfTranslationStatusEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOfTranslationStatusEnum];

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1
     */
    'type': ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1
     */
    'tenantId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1
     */
    'translationStatus': ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1TranslationStatusEnum;
}

export const ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1TypeEnum = {
    Internal: 'internal'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1TypeEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1TypeEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1TypeEnum];
export const ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1TranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1TranslationStatusEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1TranslationStatusEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf1OneOf1TranslationStatusEnum];

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOf2
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOf2 {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf2
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf2
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf2
     */
    'openIn': ArticleChangeBlocksAddedInnerVariantsValueAnyOf2OpenInEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOf2
     */
    'translationStatus': ArticleChangeBlocksAddedInnerVariantsValueAnyOf2TranslationStatusEnum;
}

export const ArticleChangeBlocksAddedInnerVariantsValueAnyOf2OpenInEnum = {
    CurrentWindow: 'current-window',
    NewWindow: 'new-window'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOf2OpenInEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf2OpenInEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf2OpenInEnum];
export const ArticleChangeBlocksAddedInnerVariantsValueAnyOf2TranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOf2TranslationStatusEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf2TranslationStatusEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOf2TranslationStatusEnum];

/**
 * @type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInner
 * @export
 */
export type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInner = ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf | ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1 | ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2;

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf
     */
    'type': ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfTypeEnum;
    /**
     * 
     * @type {Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInner>}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf
     */
    'children': Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInner>;
}

export const ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfTypeEnum = {
    Paragraph: 'paragraph'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfTypeEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfTypeEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfTypeEnum];

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1
     */
    'type': ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1
     */
    'level': number;
    /**
     * 
     * @type {Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInner>}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1
     */
    'children': Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInner>;
}

export const ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1TypeEnum = {
    Heading: 'heading'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1TypeEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1TypeEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2
     */
    'type': ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2
     */
    'listType': ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ListTypeEnum;
    /**
     * 
     * @type {Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInner>}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2
     */
    'children': Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInner>;
}

export const ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2TypeEnum = {
    List: 'list'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2TypeEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2TypeEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2TypeEnum];
export const ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ListTypeEnum = {
    Bullet: 'bullet',
    Number: 'number'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ListTypeEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ListTypeEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ListTypeEnum];

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInner
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInner {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInner
     */
    'type': ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInnerTypeEnum;
    /**
     * 
     * @type {Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInner>}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInner
     */
    'children': Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInner>;
}

export const ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInnerTypeEnum = {
    ListItem: 'list-item'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInnerTypeEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInnerTypeEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOf2ChildrenInnerTypeEnum];

/**
 * @type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInner
 * @export
 */
export type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInner = ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf | ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1;

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf
     */
    'type': ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfTypeEnum;
    /**
     * 
     * @type {ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfFormat}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf
     */
    'format': ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfFormat;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf
     */
    'value': string;
}

export const ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfTypeEnum = {
    Text: 'text'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfTypeEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfTypeEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfTypeEnum];

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1
     */
    'type': ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1
     */
    'url': string;
    /**
     * 
     * @type {Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf>}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1
     */
    'children': Array<ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf>;
}

export const ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1TypeEnum = {
    Link: 'link'
} as const;

export type ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1TypeEnum = typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1TypeEnum[keyof typeof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfFormat
 */
export interface ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfFormat {
    /**
     * 
     * @type {boolean}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfFormat
     */
    'bold'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfFormat
     */
    'italic'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ArticleChangeBlocksAddedInnerVariantsValueAnyOfItemsInnerOneOfChildrenInnerOneOfFormat
     */
    'underline'?: boolean;
}
/**
 * 
 * @export
 * @interface ArticleChangeBlocksChangedInner
 */
export interface ArticleChangeBlocksChangedInner {
    /**
     * 
     * @type {ArticleChangeBlocksAddedInner}
     * @memberof ArticleChangeBlocksChangedInner
     */
    'new': ArticleChangeBlocksAddedInner;
    /**
     * 
     * @type {ArticleChangeBlocksAddedInner}
     * @memberof ArticleChangeBlocksChangedInner
     */
    'old': ArticleChangeBlocksAddedInner;
}
/**
 * 
 * @export
 * @interface ArticleChangeChannelId
 */
export interface ArticleChangeChannelId {
    /**
     * 
     * @type {number}
     * @memberof ArticleChangeChannelId
     */
    'new': number | null;
    /**
     * 
     * @type {number}
     * @memberof ArticleChangeChannelId
     */
    'old': number | null;
}
/**
 * 
 * @export
 * @interface ArticleChangeLanguages
 */
export interface ArticleChangeLanguages {
    /**
     * 
     * @type {Array<ArticleChangeLanguagesAddedInner>}
     * @memberof ArticleChangeLanguages
     */
    'added': Array<ArticleChangeLanguagesAddedInner>;
    /**
     * 
     * @type {Array<ArticleChangeLanguagesAddedInner>}
     * @memberof ArticleChangeLanguages
     */
    'removed': Array<ArticleChangeLanguagesAddedInner>;
    /**
     * 
     * @type {Array<ArticleChangeLanguagesChangedInner>}
     * @memberof ArticleChangeLanguages
     */
    'changed': Array<ArticleChangeLanguagesChangedInner>;
}
/**
 * 
 * @export
 * @interface ArticleChangeLanguagesAddedInner
 */
export interface ArticleChangeLanguagesAddedInner {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeLanguagesAddedInner
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof ArticleChangeLanguagesAddedInner
     */
    'isDefault': boolean;
}
/**
 * 
 * @export
 * @interface ArticleChangeLanguagesChangedInner
 */
export interface ArticleChangeLanguagesChangedInner {
    /**
     * 
     * @type {ArticleChangeLanguagesAddedInner}
     * @memberof ArticleChangeLanguagesChangedInner
     */
    'new': ArticleChangeLanguagesAddedInner | null;
    /**
     * 
     * @type {ArticleChangeLanguagesAddedInner}
     * @memberof ArticleChangeLanguagesChangedInner
     */
    'old': ArticleChangeLanguagesAddedInner | null;
}
/**
 * 
 * @export
 * @interface ArticleChangePublishAt
 */
export interface ArticleChangePublishAt {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangePublishAt
     */
    'new': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangePublishAt
     */
    'old': string | null;
}
/**
 * 
 * @export
 * @interface ArticleChangeStatus
 */
export interface ArticleChangeStatus {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeStatus
     */
    'new': ArticleChangeStatusNewEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeStatus
     */
    'old': ArticleChangeStatusOldEnum;
}

export const ArticleChangeStatusNewEnum = {
    Draft: 'draft',
    Published: 'published',
    Archived: 'archived',
    Inbound: 'inbound',
    Rejected: 'rejected'
} as const;

export type ArticleChangeStatusNewEnum = typeof ArticleChangeStatusNewEnum[keyof typeof ArticleChangeStatusNewEnum];
export const ArticleChangeStatusOldEnum = {
    Draft: 'draft',
    Published: 'published',
    Archived: 'archived',
    Inbound: 'inbound',
    Rejected: 'rejected'
} as const;

export type ArticleChangeStatusOldEnum = typeof ArticleChangeStatusOldEnum[keyof typeof ArticleChangeStatusOldEnum];

/**
 * 
 * @export
 * @interface ArticleChangeUsers
 */
export interface ArticleChangeUsers {
    /**
     * 
     * @type {Array<ArticleChangeUsersAddedInner>}
     * @memberof ArticleChangeUsers
     */
    'added': Array<ArticleChangeUsersAddedInner>;
    /**
     * 
     * @type {Array<ArticleChangeUsersAddedInner>}
     * @memberof ArticleChangeUsers
     */
    'removed': Array<ArticleChangeUsersAddedInner>;
    /**
     * 
     * @type {Array<ArticleChangeUsersChangedInner>}
     * @memberof ArticleChangeUsers
     */
    'changed': Array<ArticleChangeUsersChangedInner>;
}
/**
 * 
 * @export
 * @interface ArticleChangeUsersAddedInner
 */
export interface ArticleChangeUsersAddedInner {
    /**
     * 
     * @type {number}
     * @memberof ArticleChangeUsersAddedInner
     */
    'userId': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ArticleChangeUsersAddedInner
     */
    'languages': Array<string>;
}
/**
 * 
 * @export
 * @interface ArticleChangeUsersChangedInner
 */
export interface ArticleChangeUsersChangedInner {
    /**
     * 
     * @type {ArticleChangeUsersAddedInner}
     * @memberof ArticleChangeUsersChangedInner
     */
    'new': ArticleChangeUsersAddedInner;
    /**
     * 
     * @type {ArticleChangeUsersAddedInner}
     * @memberof ArticleChangeUsersChangedInner
     */
    'old': ArticleChangeUsersAddedInner;
}
/**
 * 
 * @export
 * @interface ArticleChangeVariants
 */
export interface ArticleChangeVariants {
    /**
     * 
     * @type {{ [key: string]: ArticleChangeVariantsAddedValue; }}
     * @memberof ArticleChangeVariants
     */
    'added': { [key: string]: ArticleChangeVariantsAddedValue; };
    /**
     * 
     * @type {{ [key: string]: ArticleChangeVariantsAddedValue; }}
     * @memberof ArticleChangeVariants
     */
    'removed': { [key: string]: ArticleChangeVariantsAddedValue; };
    /**
     * 
     * @type {{ [key: string]: ArticleChangeVariantsChangedValue; }}
     * @memberof ArticleChangeVariants
     */
    'changed': { [key: string]: ArticleChangeVariantsChangedValue; };
}
/**
 * 
 * @export
 * @interface ArticleChangeVariantsAddedValue
 */
export interface ArticleChangeVariantsAddedValue {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeVariantsAddedValue
     */
    'translationStatus': ArticleChangeVariantsAddedValueTranslationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeVariantsAddedValue
     */
    'title': string;
    /**
     * 
     * @type {ArticleChangeVariantsAddedValueCoverImage}
     * @memberof ArticleChangeVariantsAddedValue
     */
    'coverImage': ArticleChangeVariantsAddedValueCoverImage;
}

export const ArticleChangeVariantsAddedValueTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ArticleChangeVariantsAddedValueTranslationStatusEnum = typeof ArticleChangeVariantsAddedValueTranslationStatusEnum[keyof typeof ArticleChangeVariantsAddedValueTranslationStatusEnum];

/**
 * @type ArticleChangeVariantsAddedValueCoverImage
 * @export
 */
export type ArticleChangeVariantsAddedValueCoverImage = ArticleChangeVariantsAddedValueCoverImageOneOf | ArticleChangeVariantsAddedValueCoverImageOneOf1;

/**
 * 
 * @export
 * @interface ArticleChangeVariantsAddedValueCoverImageOneOf
 */
export interface ArticleChangeVariantsAddedValueCoverImageOneOf {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeVariantsAddedValueCoverImageOneOf
     */
    'type': ArticleChangeVariantsAddedValueCoverImageOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeVariantsAddedValueCoverImageOneOf
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeVariantsAddedValueCoverImageOneOf
     */
    'name': string;
}

export const ArticleChangeVariantsAddedValueCoverImageOneOfTypeEnum = {
    External: 'external'
} as const;

export type ArticleChangeVariantsAddedValueCoverImageOneOfTypeEnum = typeof ArticleChangeVariantsAddedValueCoverImageOneOfTypeEnum[keyof typeof ArticleChangeVariantsAddedValueCoverImageOneOfTypeEnum];

/**
 * 
 * @export
 * @interface ArticleChangeVariantsAddedValueCoverImageOneOf1
 */
export interface ArticleChangeVariantsAddedValueCoverImageOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeVariantsAddedValueCoverImageOneOf1
     */
    'type': ArticleChangeVariantsAddedValueCoverImageOneOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleChangeVariantsAddedValueCoverImageOneOf1
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ArticleChangeVariantsAddedValueCoverImageOneOf1
     */
    'tenantId'?: number | null;
}

export const ArticleChangeVariantsAddedValueCoverImageOneOf1TypeEnum = {
    Internal: 'internal'
} as const;

export type ArticleChangeVariantsAddedValueCoverImageOneOf1TypeEnum = typeof ArticleChangeVariantsAddedValueCoverImageOneOf1TypeEnum[keyof typeof ArticleChangeVariantsAddedValueCoverImageOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface ArticleChangeVariantsChangedValue
 */
export interface ArticleChangeVariantsChangedValue {
    /**
     * 
     * @type {ArticleChangeVariantsAddedValue}
     * @memberof ArticleChangeVariantsChangedValue
     */
    'new': ArticleChangeVariantsAddedValue;
    /**
     * 
     * @type {ArticleChangeVariantsAddedValue}
     * @memberof ArticleChangeVariantsChangedValue
     */
    'old': ArticleChangeVariantsAddedValue;
}
/**
 * @type ArticleChannel
 * @export
 */
export type ArticleChannel = BasicChannelInfo;

/**
 * 
 * @export
 * @interface ArticleCollaborators
 */
export interface ArticleCollaborators extends Array<ArticleCollaboratorsInner> {
}
/**
 * 
 * @export
 * @interface ArticleCollaboratorsInner
 */
export interface ArticleCollaboratorsInner {
    /**
     * 
     * @type {number}
     * @memberof ArticleCollaboratorsInner
     */
    'id': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ArticleCollaboratorsInner
     */
    'languages': Array<string>;
}
/**
 * @type ArticleFileGet
 * @export
 */
export type ArticleFileGet = { type: 'external' } & ExternalFile | { type: 'internal' } & InternalFileGet;

/**
 * 
 * @export
 * @interface ArticleOriginalTenant
 */
export interface ArticleOriginalTenant {
    /**
     * 
     * @type {number}
     * @memberof ArticleOriginalTenant
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ArticleOriginalTenant
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ArticlePage
 */
export interface ArticlePage {
    /**
     * 
     * @type {ActionAnswerPageMeta}
     * @memberof ArticlePage
     */
    'meta': ActionAnswerPageMeta;
    /**
     * 
     * @type {Array<BasicArticleInfo>}
     * @memberof ArticlePage
     */
    'data': Array<BasicArticleInfo>;
}
/**
 * 
 * @export
 * @interface ArticleSharingStatus
 */
export interface ArticleSharingStatus {
    /**
     * 
     * @type {number}
     * @memberof ArticleSharingStatus
     */
    'articleId': number;
    /**
     * 
     * @type {string}
     * @memberof ArticleSharingStatus
     */
    'tenantName': string;
    /**
     * 
     * @type {number}
     * @memberof ArticleSharingStatus
     */
    'tenantId': number;
    /**
     * 
     * @type {number}
     * @memberof ArticleSharingStatus
     */
    'originalTenantId': number | null;
    /**
     * 
     * @type {string}
     * @memberof ArticleSharingStatus
     */
    'originalTenantName': string | null;
    /**
     * 
     * @type {number}
     * @memberof ArticleSharingStatus
     */
    'originalArticleId': number | null;
    /**
     * 
     * @type {string}
     * @memberof ArticleSharingStatus
     */
    'status': ArticleSharingStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleSharingStatus
     */
    'sharingComment': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArticleSharingStatus
     */
    'publishAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArticleSharingStatus
     */
    'archiveAt': string | null;
}

export const ArticleSharingStatusStatusEnum = {
    Draft: 'draft',
    Published: 'published',
    Archived: 'archived',
    Inbound: 'inbound',
    Rejected: 'rejected'
} as const;

export type ArticleSharingStatusStatusEnum = typeof ArticleSharingStatusStatusEnum[keyof typeof ArticleSharingStatusStatusEnum];

/**
 * 
 * @export
 * @interface ArticleVariant
 */
export interface ArticleVariant {
    /**
     * 
     * @type {string}
     * @memberof ArticleVariant
     */
    'translationStatus': ArticleVariantTranslationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleVariant
     */
    'title': string;
    /**
     * 
     * @type {CoverImageFile}
     * @memberof ArticleVariant
     */
    'coverImage': CoverImageFile;
}

export const ArticleVariantTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ArticleVariantTranslationStatusEnum = typeof ArticleVariantTranslationStatusEnum[keyof typeof ArticleVariantTranslationStatusEnum];

/**
 * 
 * @export
 * @interface ArticleVariantGet
 */
export interface ArticleVariantGet {
    /**
     * 
     * @type {string}
     * @memberof ArticleVariantGet
     */
    'translationStatus': ArticleVariantGetTranslationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ArticleVariantGet
     */
    'title': string;
    /**
     * 
     * @type {CoverImageArticleFileGet}
     * @memberof ArticleVariantGet
     */
    'coverImage': CoverImageArticleFileGet;
}

export const ArticleVariantGetTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ArticleVariantGetTranslationStatusEnum = typeof ArticleVariantGetTranslationStatusEnum[keyof typeof ArticleVariantGetTranslationStatusEnum];

/**
 * 
 * @export
 * @interface ArticleVariants
 */
export interface ArticleVariants {
    [key: string]: ArticleVariant;

}
/**
 * 
 * @export
 * @interface ArticleVariantsGet
 */
export interface ArticleVariantsGet {
    [key: string]: ArticleVariantGet;

}
/**
 * 
 * @export
 * @interface AudienceIds
 */
export interface AudienceIds extends Array<number> {
}
/**
 * 
 * @export
 * @interface BasicArticleInfo
 */
export interface BasicArticleInfo {
    /**
     * 
     * @type {number}
     * @memberof BasicArticleInfo
     */
    'id': number;
    /**
     * 
     * @type {ArticleVariantsGet}
     * @memberof BasicArticleInfo
     */
    'variants': ArticleVariantsGet;
    /**
     * 
     * @type {string}
     * @memberof BasicArticleInfo
     */
    'status': BasicArticleInfoStatusEnum;
    /**
     * 
     * @type {AudienceIds}
     * @memberof BasicArticleInfo
     */
    'audiences': AudienceIds;
    /**
     * 
     * @type {LanguageList}
     * @memberof BasicArticleInfo
     */
    'languages': LanguageList;
    /**
     * 
     * @type {Array<ArticleAudiencesResourcesInner>}
     * @memberof BasicArticleInfo
     */
    'audiencesResources'?: Array<ArticleAudiencesResourcesInner>;
    /**
     * 
     * @type {string}
     * @memberof BasicArticleInfo
     */
    'sharingComment'?: string | null;
    /**
     * 
     * @type {ArticleChannel}
     * @memberof BasicArticleInfo
     */
    'channel': ArticleChannel | null;
    /**
     * 
     * @type {number}
     * @memberof BasicArticleInfo
     */
    'createdBy'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BasicArticleInfo
     */
    'publishAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof BasicArticleInfo
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof BasicArticleInfo
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof BasicArticleInfo
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BasicArticleInfo
     */
    'updatedAt': string;
    /**
     * 
     * @type {ArticleOriginalTenant}
     * @memberof BasicArticleInfo
     */
    'originalTenant': ArticleOriginalTenant | null;
    /**
     * 
     * @type {number}
     * @memberof BasicArticleInfo
     */
    'seen': number;
}

export const BasicArticleInfoStatusEnum = {
    Draft: 'draft',
    Published: 'published',
    Archived: 'archived',
    Inbound: 'inbound',
    Rejected: 'rejected'
} as const;

export type BasicArticleInfoStatusEnum = typeof BasicArticleInfoStatusEnum[keyof typeof BasicArticleInfoStatusEnum];

/**
 * 
 * @export
 * @interface BasicChangelogInfo
 */
export interface BasicChangelogInfo {
    /**
     * 
     * @type {string}
     * @memberof BasicChangelogInfo
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof BasicChangelogInfo
     */
    'userId': number;
    /**
     * 
     * @type {ArticleChange}
     * @memberof BasicChangelogInfo
     */
    'changes': ArticleChange;
}
/**
 * 
 * @export
 * @interface BasicChannelInfo
 */
export interface BasicChannelInfo {
    /**
     * 
     * @type {number}
     * @memberof BasicChannelInfo
     */
    'id': number;
    /**
     * 
     * @type {ChannelTitleTranslation}
     * @memberof BasicChannelInfo
     */
    'title': ChannelTitleTranslation;
    /**
     * 
     * @type {BasicChannelInfoCoverImage}
     * @memberof BasicChannelInfo
     */
    'coverImage': BasicChannelInfoCoverImage | null;
    /**
     * 
     * @type {boolean}
     * @memberof BasicChannelInfo
     */
    'pushNotification': boolean;
    /**
     * 
     * @type {number}
     * @memberof BasicChannelInfo
     */
    'ranking': number;
    /**
     * 
     * @type {boolean}
     * @memberof BasicChannelInfo
     */
    'hideIfEmpty': boolean;
    /**
     * 
     * @type {string}
     * @memberof BasicChannelInfo
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BasicChannelInfo
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof BasicChannelInfo
     */
    'deletedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BasicChannelInfo
     */
    'createdBy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BasicChannelInfo
     */
    'updatedBy'?: number | null;
}
/**
 * @type BasicChannelInfoCoverImage
 * @export
 */
export type BasicChannelInfoCoverImage = CoverImageChannelFileGet;

/**
 * 
 * @export
 * @interface BasicRelevantChannelInfo
 */
export interface BasicRelevantChannelInfo {
    /**
     * 
     * @type {number}
     * @memberof BasicRelevantChannelInfo
     */
    'id': number;
    /**
     * 
     * @type {ChannelTitleTranslation}
     * @memberof BasicRelevantChannelInfo
     */
    'title': ChannelTitleTranslation;
    /**
     * 
     * @type {BasicChannelInfoCoverImage}
     * @memberof BasicRelevantChannelInfo
     */
    'coverImage': BasicChannelInfoCoverImage | null;
    /**
     * 
     * @type {number}
     * @memberof BasicRelevantChannelInfo
     */
    'ranking': number;
    /**
     * 
     * @type {number}
     * @memberof BasicRelevantChannelInfo
     */
    'articleCount': number;
    /**
     * 
     * @type {number}
     * @memberof BasicRelevantChannelInfo
     */
    'seenArticleCount'?: number;
}
/**
 * @type Block
 * @export
 */
export type Block = { type: 'image' } & ImageBlockV1 | { type: 'media_task' } & MediaTaskBlockV1 | { type: 'pdf' } & PdfBlockV1 | { type: 'simple_task' } & SimpleTaskBlockV1 | { type: 'text' } & TextBlockV1 | { type: 'url' } & UrlBlockV1 | { type: 'video' } & VideoBlockV1;

/**
 * 
 * @export
 * @interface ChangelogPage
 */
export interface ChangelogPage {
    /**
     * 
     * @type {ActionAnswerPageMeta}
     * @memberof ChangelogPage
     */
    'meta': ActionAnswerPageMeta;
    /**
     * 
     * @type {Array<BasicChangelogInfo>}
     * @memberof ChangelogPage
     */
    'data': Array<BasicChangelogInfo>;
}
/**
 * 
 * @export
 * @interface ChannelPage
 */
export interface ChannelPage {
    /**
     * 
     * @type {ActionAnswerPageMeta}
     * @memberof ChannelPage
     */
    'meta': ActionAnswerPageMeta;
    /**
     * 
     * @type {Array<BasicChannelInfo>}
     * @memberof ChannelPage
     */
    'data': Array<BasicChannelInfo>;
}
/**
 * 
 * @export
 * @interface ChannelTitle
 */
export interface ChannelTitle {
    /**
     * 
     * @type {string}
     * @memberof ChannelTitle
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelTitle
     */
    'translationStatus': ChannelTitleTranslationStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelTitle
     */
    'isDefault': boolean;
}

export const ChannelTitleTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ChannelTitleTranslationStatusEnum = typeof ChannelTitleTranslationStatusEnum[keyof typeof ChannelTitleTranslationStatusEnum];

/**
 * 
 * @export
 * @interface ChannelTitleTranslation
 */
export interface ChannelTitleTranslation {
    [key: string]: ChannelTitle;

}
/**
 * @type CoverImageArticleFileGet
 * @export
 */
export type CoverImageArticleFileGet = { type: 'external' } & CoverImageExternalFile | { type: 'internal' } & CoverImageInternalFileGet;

/**
 * @type CoverImageChannelFileGet
 * @export
 */
export type CoverImageChannelFileGet = { type: 'external' } & CoverImageExternalFile | { type: 'internal' } & CoverImageChannelInternalFileGet;

/**
 * 
 * @export
 * @interface CoverImageChannelInternalFileGet
 */
export interface CoverImageChannelInternalFileGet {
    /**
     * 
     * @type {string}
     * @memberof CoverImageChannelInternalFileGet
     */
    'type': CoverImageChannelInternalFileGetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CoverImageChannelInternalFileGet
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CoverImageChannelInternalFileGet
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CoverImageChannelInternalFileGet
     */
    'id': string;
}

export const CoverImageChannelInternalFileGetTypeEnum = {
    Internal: 'internal'
} as const;

export type CoverImageChannelInternalFileGetTypeEnum = typeof CoverImageChannelInternalFileGetTypeEnum[keyof typeof CoverImageChannelInternalFileGetTypeEnum];

/**
 * 
 * @export
 * @interface CoverImageExternalFile
 */
export interface CoverImageExternalFile {
    /**
     * 
     * @type {string}
     * @memberof CoverImageExternalFile
     */
    'type': CoverImageExternalFileTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CoverImageExternalFile
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CoverImageExternalFile
     */
    'name': string;
}

export const CoverImageExternalFileTypeEnum = {
    External: 'external'
} as const;

export type CoverImageExternalFileTypeEnum = typeof CoverImageExternalFileTypeEnum[keyof typeof CoverImageExternalFileTypeEnum];

/**
 * @type CoverImageFile
 * @export
 */
export type CoverImageFile = { type: 'external' } & CoverImageExternalFile | { type: 'internal' } & CoverImageInternalFile;

/**
 * 
 * @export
 * @interface CoverImageInternalFile
 */
export interface CoverImageInternalFile {
    /**
     * 
     * @type {string}
     * @memberof CoverImageInternalFile
     */
    'type': CoverImageInternalFileTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CoverImageInternalFile
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof CoverImageInternalFile
     */
    'tenantId'?: number | null;
}

export const CoverImageInternalFileTypeEnum = {
    Internal: 'internal'
} as const;

export type CoverImageInternalFileTypeEnum = typeof CoverImageInternalFileTypeEnum[keyof typeof CoverImageInternalFileTypeEnum];

/**
 * 
 * @export
 * @interface CoverImageInternalFileGet
 */
export interface CoverImageInternalFileGet {
    /**
     * 
     * @type {string}
     * @memberof CoverImageInternalFileGet
     */
    'type': CoverImageInternalFileGetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CoverImageInternalFileGet
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CoverImageInternalFileGet
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CoverImageInternalFileGet
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof CoverImageInternalFileGet
     */
    'tenantId'?: number;
    /**
     * 
     * @type {string}
     * @memberof CoverImageInternalFileGet
     */
    'message'?: string | null;
}

export const CoverImageInternalFileGetTypeEnum = {
    Internal: 'internal'
} as const;

export type CoverImageInternalFileGetTypeEnum = typeof CoverImageInternalFileGetTypeEnum[keyof typeof CoverImageInternalFileGetTypeEnum];

/**
 * 
 * @export
 * @interface CreatedFileSlot
 */
export interface CreatedFileSlot {
    /**
     * 
     * @type {string}
     * @memberof CreatedFileSlot
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreatedFileSlot
     */
    'url': string;
    /**
     * 
     * @type {object}
     * @memberof CreatedFileSlot
     */
    'headers': object;
}
/**
 * 
 * @export
 * @interface CreatedSharingConnection
 */
export interface CreatedSharingConnection {
    /**
     * 
     * @type {number}
     * @memberof CreatedSharingConnection
     */
    'receiverTenant': number;
    /**
     * 
     * @type {number}
     * @memberof CreatedSharingConnection
     */
    'sourceTenant': number;
    /**
     * 
     * @type {number}
     * @memberof CreatedSharingConnection
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface DeleteSharedArticleRequest
 */
export interface DeleteSharedArticleRequest {
    /**
     * 
     * @type {number}
     * @memberof DeleteSharedArticleRequest
     */
    'articleId': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DeleteSharedArticleRequest
     */
    'tenantIds': Array<number> | null;
}
/**
 * 
 * @export
 * @interface DeleteSharedArticleResponse
 */
export interface DeleteSharedArticleResponse {
    /**
     * 
     * @type {Array<DeleteSharedArticleResponseTenantsInner>}
     * @memberof DeleteSharedArticleResponse
     */
    'tenants': Array<DeleteSharedArticleResponseTenantsInner>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DeleteSharedArticleResponse
     */
    'articles': Array<number>;
}
/**
 * 
 * @export
 * @interface DeleteSharedArticleResponseTenantsInner
 */
export interface DeleteSharedArticleResponseTenantsInner {
    /**
     * 
     * @type {string}
     * @memberof DeleteSharedArticleResponseTenantsInner
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DeleteSharedArticleResponseTenantsInner
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ExternalFile
 */
export interface ExternalFile {
    /**
     * 
     * @type {string}
     * @memberof ExternalFile
     */
    'type': ExternalFileTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ExternalFile
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalFile
     */
    'translationStatus': ExternalFileTranslationStatusEnum;
}

export const ExternalFileTypeEnum = {
    External: 'external'
} as const;

export type ExternalFileTypeEnum = typeof ExternalFileTypeEnum[keyof typeof ExternalFileTypeEnum];
export const ExternalFileTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type ExternalFileTranslationStatusEnum = typeof ExternalFileTranslationStatusEnum[keyof typeof ExternalFileTranslationStatusEnum];

/**
 * 
 * @export
 * @interface FileSlot
 */
export interface FileSlot {
    /**
     * 
     * @type {string}
     * @memberof FileSlot
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FileSlot
     */
    'mimeType': string;
}
/**
 * @type FileVariant
 * @export
 */
export type FileVariant = { type: 'external' } & ExternalFile | { type: 'internal' } & InternalFile;

/**
 * 
 * @export
 * @interface GetActionAnswer400Response
 */
export interface GetActionAnswer400Response {
}
/**
 * 
 * @export
 * @interface GetActionAnswer400ResponseAnyOfInner
 */
export interface GetActionAnswer400ResponseAnyOfInner {
    /**
     * 
     * @type {string}
     * @memberof GetActionAnswer400ResponseAnyOfInner
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetChangeLog400Response
 */
export interface GetChangeLog400Response {
}
/**
 * 
 * @export
 * @interface GetFile200Response
 */
export interface GetFile200Response {
    /**
     * 
     * @type {string}
     * @memberof GetFile200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface Heading
 */
export interface Heading {
    /**
     * 
     * @type {string}
     * @memberof Heading
     */
    'type': HeadingTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Heading
     */
    'level': number;
    /**
     * 
     * @type {Array<TextOrLink>}
     * @memberof Heading
     */
    'children': Array<TextOrLink>;
}

export const HeadingTypeEnum = {
    Heading: 'heading'
} as const;

export type HeadingTypeEnum = typeof HeadingTypeEnum[keyof typeof HeadingTypeEnum];

/**
 * 
 * @export
 * @interface ImageBlock
 */
export interface ImageBlock {
    /**
     * 
     * @type {number}
     * @memberof ImageBlock
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ImageBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof ImageBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof ImageBlock
     */
    'version': ImageBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof ImageBlock
     */
    'type': ImageBlockTypeEnum;
    /**
     * 
     * @type {ImageBlockVariants}
     * @memberof ImageBlock
     */
    'variants': ImageBlockVariants;
}

export const ImageBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type ImageBlockVersionEnum = typeof ImageBlockVersionEnum[keyof typeof ImageBlockVersionEnum];
export const ImageBlockTypeEnum = {
    Image: 'image'
} as const;

export type ImageBlockTypeEnum = typeof ImageBlockTypeEnum[keyof typeof ImageBlockTypeEnum];

/**
 * 
 * @export
 * @interface ImageBlockV1
 */
export interface ImageBlockV1 {
    /**
     * 
     * @type {number}
     * @memberof ImageBlockV1
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ImageBlockV1
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof ImageBlockV1
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof ImageBlockV1
     */
    'version': ImageBlockV1VersionEnum;
    /**
     * 
     * @type {number}
     * @memberof ImageBlockV1
     */
    'articleId': number;
    /**
     * 
     * @type {string}
     * @memberof ImageBlockV1
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ImageBlockV1
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ImageBlockV1
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageBlockV1
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageBlockV1
     */
    'type': ImageBlockV1TypeEnum;
    /**
     * 
     * @type {ImageBlockV1Variants}
     * @memberof ImageBlockV1
     */
    'variants': ImageBlockV1Variants;
}

export const ImageBlockV1VersionEnum = {
    NUMBER_1: 1
} as const;

export type ImageBlockV1VersionEnum = typeof ImageBlockV1VersionEnum[keyof typeof ImageBlockV1VersionEnum];
export const ImageBlockV1TypeEnum = {
    Image: 'image'
} as const;

export type ImageBlockV1TypeEnum = typeof ImageBlockV1TypeEnum[keyof typeof ImageBlockV1TypeEnum];

/**
 * 
 * @export
 * @interface ImageBlockV1Variants
 */
export interface ImageBlockV1Variants {
    [key: string]: ArticleFileGet;

}
/**
 * 
 * @export
 * @interface ImageBlockVariants
 */
export interface ImageBlockVariants {
    [key: string]: FileVariant;

}
/**
 * 
 * @export
 * @interface InternalFile
 */
export interface InternalFile {
    /**
     * 
     * @type {string}
     * @memberof InternalFile
     */
    'type': InternalFileTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InternalFile
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof InternalFile
     */
    'tenantId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InternalFile
     */
    'translationStatus': InternalFileTranslationStatusEnum;
}

export const InternalFileTypeEnum = {
    Internal: 'internal'
} as const;

export type InternalFileTypeEnum = typeof InternalFileTypeEnum[keyof typeof InternalFileTypeEnum];
export const InternalFileTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type InternalFileTranslationStatusEnum = typeof InternalFileTranslationStatusEnum[keyof typeof InternalFileTranslationStatusEnum];

/**
 * 
 * @export
 * @interface InternalFileGet
 */
export interface InternalFileGet {
    /**
     * 
     * @type {string}
     * @memberof InternalFileGet
     */
    'type': InternalFileGetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InternalFileGet
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InternalFileGet
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof InternalFileGet
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InternalFileGet
     */
    'translationStatus': InternalFileGetTranslationStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof InternalFileGet
     */
    'tenantId': number;
    /**
     * 
     * @type {string}
     * @memberof InternalFileGet
     */
    'message'?: string | null;
}

export const InternalFileGetTypeEnum = {
    Internal: 'internal'
} as const;

export type InternalFileGetTypeEnum = typeof InternalFileGetTypeEnum[keyof typeof InternalFileGetTypeEnum];
export const InternalFileGetTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type InternalFileGetTranslationStatusEnum = typeof InternalFileGetTranslationStatusEnum[keyof typeof InternalFileGetTranslationStatusEnum];

/**
 * 
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    'isDefault': boolean;
}
/**
 * 
 * @export
 * @interface LanguageList
 */
export interface LanguageList extends Array<Language> {
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type': LinkTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'url': string;
    /**
     * 
     * @type {Array<Text>}
     * @memberof Link
     */
    'children': Array<Text>;
}

export const LinkTypeEnum = {
    Link: 'link'
} as const;

export type LinkTypeEnum = typeof LinkTypeEnum[keyof typeof LinkTypeEnum];

/**
 * 
 * @export
 * @interface List
 */
export interface List {
    /**
     * 
     * @type {string}
     * @memberof List
     */
    'type': ListTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof List
     */
    'listType': ListListTypeEnum;
    /**
     * 
     * @type {Array<ListItem>}
     * @memberof List
     */
    'children': Array<ListItem>;
}

export const ListTypeEnum = {
    List: 'list'
} as const;

export type ListTypeEnum = typeof ListTypeEnum[keyof typeof ListTypeEnum];
export const ListListTypeEnum = {
    Bullet: 'bullet',
    Number: 'number'
} as const;

export type ListListTypeEnum = typeof ListListTypeEnum[keyof typeof ListListTypeEnum];

/**
 * 
 * @export
 * @interface ListItem
 */
export interface ListItem {
    /**
     * 
     * @type {string}
     * @memberof ListItem
     */
    'type': ListItemTypeEnum;
    /**
     * 
     * @type {Array<TextOrLink>}
     * @memberof ListItem
     */
    'children': Array<TextOrLink>;
}

export const ListItemTypeEnum = {
    ListItem: 'list-item'
} as const;

export type ListItemTypeEnum = typeof ListItemTypeEnum[keyof typeof ListItemTypeEnum];

/**
 * 
 * @export
 * @interface MediaTaskBlock
 */
export interface MediaTaskBlock {
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlock
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlock
     */
    'version': MediaTaskBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskBlock
     */
    'type': MediaTaskBlockTypeEnum;
    /**
     * 
     * @type {MediaTaskBlockVariants}
     * @memberof MediaTaskBlock
     */
    'variants': MediaTaskBlockVariants;
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlock
     */
    'required': number;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskBlock
     */
    'category': MediaTaskBlockCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskBlock
     */
    'deadline': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaTaskBlock
     */
    'public': boolean;
    /**
     * 
     * @type {AudienceIds}
     * @memberof MediaTaskBlock
     */
    'audiences': AudienceIds;
}

export const MediaTaskBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type MediaTaskBlockVersionEnum = typeof MediaTaskBlockVersionEnum[keyof typeof MediaTaskBlockVersionEnum];
export const MediaTaskBlockTypeEnum = {
    MediaTask: 'media_task'
} as const;

export type MediaTaskBlockTypeEnum = typeof MediaTaskBlockTypeEnum[keyof typeof MediaTaskBlockTypeEnum];
export const MediaTaskBlockCategoryEnum = {
    Accounting: 'Accounting',
    Safety: 'Safety',
    Training: 'Training',
    ContentRating: 'Content Rating',
    ContentAcceptance: 'Content Acceptance',
    Appearance: 'Appearance',
    Motivational: 'Motivational'
} as const;

export type MediaTaskBlockCategoryEnum = typeof MediaTaskBlockCategoryEnum[keyof typeof MediaTaskBlockCategoryEnum];

/**
 * 
 * @export
 * @interface MediaTaskBlockV1
 */
export interface MediaTaskBlockV1 {
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlockV1
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlockV1
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlockV1
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlockV1
     */
    'version': MediaTaskBlockV1VersionEnum;
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlockV1
     */
    'articleId': number;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskBlockV1
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskBlockV1
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskBlockV1
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskBlockV1
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskBlockV1
     */
    'type': MediaTaskBlockV1TypeEnum;
    /**
     * 
     * @type {MediaTaskBlockV1Variants}
     * @memberof MediaTaskBlockV1
     */
    'variants': MediaTaskBlockV1Variants;
    /**
     * 
     * @type {number}
     * @memberof MediaTaskBlockV1
     */
    'required': number;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskBlockV1
     */
    'category': MediaTaskBlockV1CategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskBlockV1
     */
    'deadline': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaTaskBlockV1
     */
    'public': boolean;
    /**
     * 
     * @type {AudienceIds}
     * @memberof MediaTaskBlockV1
     */
    'audiences': AudienceIds;
    /**
     * 
     * @type {boolean}
     * @memberof MediaTaskBlockV1
     */
    'completed': boolean;
    /**
     * 
     * @type {UserAnswers}
     * @memberof MediaTaskBlockV1
     */
    'currentUserAnswers': UserAnswers;
}

export const MediaTaskBlockV1VersionEnum = {
    NUMBER_1: 1
} as const;

export type MediaTaskBlockV1VersionEnum = typeof MediaTaskBlockV1VersionEnum[keyof typeof MediaTaskBlockV1VersionEnum];
export const MediaTaskBlockV1TypeEnum = {
    MediaTask: 'media_task'
} as const;

export type MediaTaskBlockV1TypeEnum = typeof MediaTaskBlockV1TypeEnum[keyof typeof MediaTaskBlockV1TypeEnum];
export const MediaTaskBlockV1CategoryEnum = {
    Accounting: 'Accounting',
    Safety: 'Safety',
    Training: 'Training',
    ContentRating: 'Content Rating',
    ContentAcceptance: 'Content Acceptance',
    Appearance: 'Appearance',
    Motivational: 'Motivational'
} as const;

export type MediaTaskBlockV1CategoryEnum = typeof MediaTaskBlockV1CategoryEnum[keyof typeof MediaTaskBlockV1CategoryEnum];

/**
 * 
 * @export
 * @interface MediaTaskBlockV1Variants
 */
export interface MediaTaskBlockV1Variants {
    [key: string]: MediaTaskVariant;

}
/**
 * 
 * @export
 * @interface MediaTaskBlockVariants
 */
export interface MediaTaskBlockVariants {
    [key: string]: MediaTaskVariant;

}
/**
 * 
 * @export
 * @interface MediaTaskVariant
 */
export interface MediaTaskVariant {
    /**
     * 
     * @type {string}
     * @memberof MediaTaskVariant
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof MediaTaskVariant
     */
    'translationStatus': MediaTaskVariantTranslationStatusEnum;
}

export const MediaTaskVariantTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type MediaTaskVariantTranslationStatusEnum = typeof MediaTaskVariantTranslationStatusEnum[keyof typeof MediaTaskVariantTranslationStatusEnum];

/**
 * 
 * @export
 * @interface NewActionAnswer
 */
export interface NewActionAnswer {
    /**
     * 
     * @type {number}
     * @memberof NewActionAnswer
     */
    'actionId': number;
    /**
     * 
     * @type {string}
     * @memberof NewActionAnswer
     */
    'answer': string;
}
/**
 * 
 * @export
 * @interface NewArticle
 */
export interface NewArticle {
    /**
     * 
     * @type {ArticleVariants}
     * @memberof NewArticle
     */
    'variants': ArticleVariants;
    /**
     * 
     * @type {string}
     * @memberof NewArticle
     */
    'status': NewArticleStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof NewArticle
     */
    'publishAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof NewArticle
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {Array<NewBlock>}
     * @memberof NewArticle
     */
    'blocks': Array<NewBlock>;
    /**
     * 
     * @type {Array<number>}
     * @memberof NewArticle
     */
    'audiences': Array<number>;
    /**
     * 
     * @type {ArticleCollaborators}
     * @memberof NewArticle
     */
    'users': ArticleCollaborators;
    /**
     * 
     * @type {Array<NewArticleLanguagesInner>}
     * @memberof NewArticle
     */
    'languages': Array<NewArticleLanguagesInner>;
    /**
     * 
     * @type {number}
     * @memberof NewArticle
     */
    'channelId': number | null;
}

export const NewArticleStatusEnum = {
    Draft: 'draft',
    Published: 'published',
    Archived: 'archived',
    Inbound: 'inbound'
} as const;

export type NewArticleStatusEnum = typeof NewArticleStatusEnum[keyof typeof NewArticleStatusEnum];

/**
 * 
 * @export
 * @interface NewArticleLanguagesInner
 */
export interface NewArticleLanguagesInner {
    /**
     * 
     * @type {string}
     * @memberof NewArticleLanguagesInner
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof NewArticleLanguagesInner
     */
    'isDefault': boolean;
}
/**
 * @type NewBlock
 * @export
 */
export type NewBlock = { type: 'image' } & NewImageBlock | { type: 'media_task' } & NewMediaTaskBlock | { type: 'pdf' } & NewPdfBlock | { type: 'simple_task' } & NewSimpleTaskBlock | { type: 'text' } & NewTextBlock | { type: 'url' } & NewUrlBlock | { type: 'video' } & NewVideoBlock;

/**
 * 
 * @export
 * @interface NewChannel
 */
export interface NewChannel {
    /**
     * 
     * @type {ChannelTitleTranslation}
     * @memberof NewChannel
     */
    'title': ChannelTitleTranslation;
    /**
     * 
     * @type {CoverImageFile}
     * @memberof NewChannel
     */
    'coverImage': CoverImageFile;
    /**
     * 
     * @type {boolean}
     * @memberof NewChannel
     */
    'pushNotification': boolean;
    /**
     * 
     * @type {number}
     * @memberof NewChannel
     */
    'ranking': number;
    /**
     * 
     * @type {boolean}
     * @memberof NewChannel
     */
    'hideIfEmpty': boolean;
}
/**
 * 
 * @export
 * @interface NewEvent
 */
export interface NewEvent {
    /**
     * 
     * @type {number}
     * @memberof NewEvent
     */
    'objectId': number;
    /**
     * 
     * @type {string}
     * @memberof NewEvent
     */
    'objectType': NewEventObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NewEvent
     */
    'event': NewEventEventEnum;
}

export const NewEventObjectTypeEnum = {
    Article: 'article'
} as const;

export type NewEventObjectTypeEnum = typeof NewEventObjectTypeEnum[keyof typeof NewEventObjectTypeEnum];
export const NewEventEventEnum = {
    Seen: 'seen'
} as const;

export type NewEventEventEnum = typeof NewEventEventEnum[keyof typeof NewEventEventEnum];

/**
 * 
 * @export
 * @interface NewImageBlock
 */
export interface NewImageBlock {
    /**
     * 
     * @type {number}
     * @memberof NewImageBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof NewImageBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof NewImageBlock
     */
    'version': NewImageBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof NewImageBlock
     */
    'type': NewImageBlockTypeEnum;
    /**
     * 
     * @type {NewImageBlockVariants}
     * @memberof NewImageBlock
     */
    'variants': NewImageBlockVariants;
}

export const NewImageBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type NewImageBlockVersionEnum = typeof NewImageBlockVersionEnum[keyof typeof NewImageBlockVersionEnum];
export const NewImageBlockTypeEnum = {
    Image: 'image'
} as const;

export type NewImageBlockTypeEnum = typeof NewImageBlockTypeEnum[keyof typeof NewImageBlockTypeEnum];

/**
 * 
 * @export
 * @interface NewImageBlockVariants
 */
export interface NewImageBlockVariants {
    [key: string]: FileVariant;

}
/**
 * 
 * @export
 * @interface NewMediaTaskBlock
 */
export interface NewMediaTaskBlock {
    /**
     * 
     * @type {number}
     * @memberof NewMediaTaskBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof NewMediaTaskBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof NewMediaTaskBlock
     */
    'version': NewMediaTaskBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof NewMediaTaskBlock
     */
    'type': NewMediaTaskBlockTypeEnum;
    /**
     * 
     * @type {NewMediaTaskBlockVariants}
     * @memberof NewMediaTaskBlock
     */
    'variants': NewMediaTaskBlockVariants;
    /**
     * 
     * @type {number}
     * @memberof NewMediaTaskBlock
     */
    'required': number;
    /**
     * 
     * @type {string}
     * @memberof NewMediaTaskBlock
     */
    'category': NewMediaTaskBlockCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof NewMediaTaskBlock
     */
    'deadline': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof NewMediaTaskBlock
     */
    'public': boolean;
    /**
     * 
     * @type {AudienceIds}
     * @memberof NewMediaTaskBlock
     */
    'audiences': AudienceIds;
}

export const NewMediaTaskBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type NewMediaTaskBlockVersionEnum = typeof NewMediaTaskBlockVersionEnum[keyof typeof NewMediaTaskBlockVersionEnum];
export const NewMediaTaskBlockTypeEnum = {
    MediaTask: 'media_task'
} as const;

export type NewMediaTaskBlockTypeEnum = typeof NewMediaTaskBlockTypeEnum[keyof typeof NewMediaTaskBlockTypeEnum];
export const NewMediaTaskBlockCategoryEnum = {
    Accounting: 'Accounting',
    Safety: 'Safety',
    Training: 'Training',
    ContentRating: 'Content Rating',
    ContentAcceptance: 'Content Acceptance',
    Appearance: 'Appearance',
    Motivational: 'Motivational'
} as const;

export type NewMediaTaskBlockCategoryEnum = typeof NewMediaTaskBlockCategoryEnum[keyof typeof NewMediaTaskBlockCategoryEnum];

/**
 * 
 * @export
 * @interface NewMediaTaskBlockVariants
 */
export interface NewMediaTaskBlockVariants {
    [key: string]: MediaTaskVariant;

}
/**
 * 
 * @export
 * @interface NewPdfBlock
 */
export interface NewPdfBlock {
    /**
     * 
     * @type {number}
     * @memberof NewPdfBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof NewPdfBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof NewPdfBlock
     */
    'version': NewPdfBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof NewPdfBlock
     */
    'type': NewPdfBlockTypeEnum;
    /**
     * 
     * @type {NewPdfBlockVariants}
     * @memberof NewPdfBlock
     */
    'variants': NewPdfBlockVariants;
}

export const NewPdfBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type NewPdfBlockVersionEnum = typeof NewPdfBlockVersionEnum[keyof typeof NewPdfBlockVersionEnum];
export const NewPdfBlockTypeEnum = {
    Pdf: 'pdf'
} as const;

export type NewPdfBlockTypeEnum = typeof NewPdfBlockTypeEnum[keyof typeof NewPdfBlockTypeEnum];

/**
 * 
 * @export
 * @interface NewPdfBlockVariants
 */
export interface NewPdfBlockVariants {
    [key: string]: FileVariant;

}
/**
 * 
 * @export
 * @interface NewSharingConnection
 */
export interface NewSharingConnection {
    /**
     * 
     * @type {number}
     * @memberof NewSharingConnection
     */
    'receiverTenant': number;
}
/**
 * 
 * @export
 * @interface NewSimpleTaskBlock
 */
export interface NewSimpleTaskBlock {
    /**
     * 
     * @type {number}
     * @memberof NewSimpleTaskBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof NewSimpleTaskBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof NewSimpleTaskBlock
     */
    'version': NewSimpleTaskBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleTaskBlock
     */
    'type': NewSimpleTaskBlockTypeEnum;
    /**
     * 
     * @type {NewSimpleTaskBlockVariants}
     * @memberof NewSimpleTaskBlock
     */
    'variants': NewSimpleTaskBlockVariants;
    /**
     * 
     * @type {number}
     * @memberof NewSimpleTaskBlock
     */
    'required': number;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleTaskBlock
     */
    'category': NewSimpleTaskBlockCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleTaskBlock
     */
    'deadline': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof NewSimpleTaskBlock
     */
    'public': boolean;
    /**
     * 
     * @type {AudienceIds}
     * @memberof NewSimpleTaskBlock
     */
    'audiences': AudienceIds;
}

export const NewSimpleTaskBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type NewSimpleTaskBlockVersionEnum = typeof NewSimpleTaskBlockVersionEnum[keyof typeof NewSimpleTaskBlockVersionEnum];
export const NewSimpleTaskBlockTypeEnum = {
    SimpleTask: 'simple_task'
} as const;

export type NewSimpleTaskBlockTypeEnum = typeof NewSimpleTaskBlockTypeEnum[keyof typeof NewSimpleTaskBlockTypeEnum];
export const NewSimpleTaskBlockCategoryEnum = {
    Accounting: 'Accounting',
    Safety: 'Safety',
    Training: 'Training',
    ContentRating: 'Content Rating',
    ContentAcceptance: 'Content Acceptance',
    Appearance: 'Appearance',
    Motivational: 'Motivational'
} as const;

export type NewSimpleTaskBlockCategoryEnum = typeof NewSimpleTaskBlockCategoryEnum[keyof typeof NewSimpleTaskBlockCategoryEnum];

/**
 * 
 * @export
 * @interface NewSimpleTaskBlockVariants
 */
export interface NewSimpleTaskBlockVariants {
    [key: string]: SimpleTaskVariant;

}
/**
 * 
 * @export
 * @interface NewTextBlock
 */
export interface NewTextBlock {
    /**
     * 
     * @type {number}
     * @memberof NewTextBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof NewTextBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof NewTextBlock
     */
    'version': NewTextBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof NewTextBlock
     */
    'type': NewTextBlockTypeEnum;
    /**
     * 
     * @type {NewTextBlockVariants}
     * @memberof NewTextBlock
     */
    'variants': NewTextBlockVariants;
}

export const NewTextBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type NewTextBlockVersionEnum = typeof NewTextBlockVersionEnum[keyof typeof NewTextBlockVersionEnum];
export const NewTextBlockTypeEnum = {
    Text: 'text'
} as const;

export type NewTextBlockTypeEnum = typeof NewTextBlockTypeEnum[keyof typeof NewTextBlockTypeEnum];

/**
 * 
 * @export
 * @interface NewTextBlockVariants
 */
export interface NewTextBlockVariants {
    [key: string]: TextBlockVariant;

}
/**
 * 
 * @export
 * @interface NewUrlBlock
 */
export interface NewUrlBlock {
    /**
     * 
     * @type {number}
     * @memberof NewUrlBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof NewUrlBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof NewUrlBlock
     */
    'version': NewUrlBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof NewUrlBlock
     */
    'type': NewUrlBlockTypeEnum;
    /**
     * 
     * @type {NewUrlBlockVariants}
     * @memberof NewUrlBlock
     */
    'variants': NewUrlBlockVariants;
}

export const NewUrlBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type NewUrlBlockVersionEnum = typeof NewUrlBlockVersionEnum[keyof typeof NewUrlBlockVersionEnum];
export const NewUrlBlockTypeEnum = {
    Url: 'url'
} as const;

export type NewUrlBlockTypeEnum = typeof NewUrlBlockTypeEnum[keyof typeof NewUrlBlockTypeEnum];

/**
 * 
 * @export
 * @interface NewUrlBlockVariants
 */
export interface NewUrlBlockVariants {
    [key: string]: UrlVariant;

}
/**
 * 
 * @export
 * @interface NewVideoBlock
 */
export interface NewVideoBlock {
    /**
     * 
     * @type {number}
     * @memberof NewVideoBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof NewVideoBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof NewVideoBlock
     */
    'version': NewVideoBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof NewVideoBlock
     */
    'type': NewVideoBlockTypeEnum;
    /**
     * 
     * @type {NewVideoBlockVariants}
     * @memberof NewVideoBlock
     */
    'variants': NewVideoBlockVariants;
}

export const NewVideoBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type NewVideoBlockVersionEnum = typeof NewVideoBlockVersionEnum[keyof typeof NewVideoBlockVersionEnum];
export const NewVideoBlockTypeEnum = {
    Video: 'video'
} as const;

export type NewVideoBlockTypeEnum = typeof NewVideoBlockTypeEnum[keyof typeof NewVideoBlockTypeEnum];

/**
 * 
 * @export
 * @interface NewVideoBlockVariants
 */
export interface NewVideoBlockVariants {
    [key: string]: FileVariant;

}
/**
 * 
 * @export
 * @interface Paragraph
 */
export interface Paragraph {
    /**
     * 
     * @type {string}
     * @memberof Paragraph
     */
    'type': ParagraphTypeEnum;
    /**
     * 
     * @type {Array<TextOrLink>}
     * @memberof Paragraph
     */
    'children': Array<TextOrLink>;
}

export const ParagraphTypeEnum = {
    Paragraph: 'paragraph'
} as const;

export type ParagraphTypeEnum = typeof ParagraphTypeEnum[keyof typeof ParagraphTypeEnum];

/**
 * 
 * @export
 * @interface PdfBlock
 */
export interface PdfBlock {
    /**
     * 
     * @type {number}
     * @memberof PdfBlock
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PdfBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof PdfBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof PdfBlock
     */
    'version': PdfBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof PdfBlock
     */
    'type': PdfBlockTypeEnum;
    /**
     * 
     * @type {PdfBlockVariants}
     * @memberof PdfBlock
     */
    'variants': PdfBlockVariants;
}

export const PdfBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type PdfBlockVersionEnum = typeof PdfBlockVersionEnum[keyof typeof PdfBlockVersionEnum];
export const PdfBlockTypeEnum = {
    Pdf: 'pdf'
} as const;

export type PdfBlockTypeEnum = typeof PdfBlockTypeEnum[keyof typeof PdfBlockTypeEnum];

/**
 * 
 * @export
 * @interface PdfBlockV1
 */
export interface PdfBlockV1 {
    /**
     * 
     * @type {number}
     * @memberof PdfBlockV1
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PdfBlockV1
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof PdfBlockV1
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof PdfBlockV1
     */
    'version': PdfBlockV1VersionEnum;
    /**
     * 
     * @type {number}
     * @memberof PdfBlockV1
     */
    'articleId': number;
    /**
     * 
     * @type {string}
     * @memberof PdfBlockV1
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PdfBlockV1
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PdfBlockV1
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof PdfBlockV1
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof PdfBlockV1
     */
    'type': PdfBlockV1TypeEnum;
    /**
     * 
     * @type {PdfBlockV1Variants}
     * @memberof PdfBlockV1
     */
    'variants': PdfBlockV1Variants;
}

export const PdfBlockV1VersionEnum = {
    NUMBER_1: 1
} as const;

export type PdfBlockV1VersionEnum = typeof PdfBlockV1VersionEnum[keyof typeof PdfBlockV1VersionEnum];
export const PdfBlockV1TypeEnum = {
    Pdf: 'pdf'
} as const;

export type PdfBlockV1TypeEnum = typeof PdfBlockV1TypeEnum[keyof typeof PdfBlockV1TypeEnum];

/**
 * 
 * @export
 * @interface PdfBlockV1Variants
 */
export interface PdfBlockV1Variants {
    [key: string]: ArticleFileGet;

}
/**
 * 
 * @export
 * @interface PdfBlockVariants
 */
export interface PdfBlockVariants {
    [key: string]: FileVariant;

}
/**
 * 
 * @export
 * @interface PostActionAnswerValidationIssue
 */
export interface PostActionAnswerValidationIssue {
    /**
     * 
     * @type {string}
     * @memberof PostActionAnswerValidationIssue
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface RelevantChannelPage
 */
export interface RelevantChannelPage {
    /**
     * 
     * @type {ActionAnswerPageMeta}
     * @memberof RelevantChannelPage
     */
    'meta': ActionAnswerPageMeta;
    /**
     * 
     * @type {Array<BasicRelevantChannelInfo>}
     * @memberof RelevantChannelPage
     */
    'data': Array<BasicRelevantChannelInfo>;
}
/**
 * 
 * @export
 * @interface RevertAction
 */
export interface RevertAction {
    /**
     * 
     * @type {number}
     * @memberof RevertAction
     */
    'actionId': number;
}
/**
 * 
 * @export
 * @interface RevertAnswer
 */
export interface RevertAnswer {
    /**
     * 
     * @type {number}
     * @memberof RevertAnswer
     */
    'answerId': number;
}
/**
 * 
 * @export
 * @interface ShareArticleRequest
 */
export interface ShareArticleRequest {
    /**
     * 
     * @type {number}
     * @memberof ShareArticleRequest
     */
    'articleId': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ShareArticleRequest
     */
    'receiverTenants': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ShareArticleRequest
     */
    'includeAssets': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShareArticleRequest
     */
    'allowResharing': boolean;
    /**
     * 
     * @type {string}
     * @memberof ShareArticleRequest
     */
    'sharingComment'?: string | null;
}
/**
 * 
 * @export
 * @interface ShareArticleResponse
 */
export interface ShareArticleResponse extends Array<ShareArticleResponseInner> {
}
/**
 * 
 * @export
 * @interface ShareArticleResponseInner
 */
export interface ShareArticleResponseInner {
    /**
     * 
     * @type {number}
     * @memberof ShareArticleResponseInner
     */
    'articleId': number;
    /**
     * 
     * @type {string}
     * @memberof ShareArticleResponseInner
     */
    'tenant': string;
}
/**
 * 
 * @export
 * @interface SharedTenants
 */
export interface SharedTenants {
    /**
     * 
     * @type {number}
     * @memberof SharedTenants
     */
    'sourceId': number;
    /**
     * 
     * @type {string}
     * @memberof SharedTenants
     */
    'sourceName': string;
    /**
     * 
     * @type {Array<Tenant>}
     * @memberof SharedTenants
     */
    'receivers': Array<Tenant> | null;
}
/**
 * 
 * @export
 * @interface SharingStatusOverviewResponse
 */
export interface SharingStatusOverviewResponse extends Array<ArticleSharingStatus> {
}
/**
 * 
 * @export
 * @interface SimpleTaskBlock
 */
export interface SimpleTaskBlock {
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlock
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlock
     */
    'version': SimpleTaskBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskBlock
     */
    'type': SimpleTaskBlockTypeEnum;
    /**
     * 
     * @type {SimpleTaskBlockVariants}
     * @memberof SimpleTaskBlock
     */
    'variants': SimpleTaskBlockVariants;
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlock
     */
    'required': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskBlock
     */
    'category': SimpleTaskBlockCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskBlock
     */
    'deadline': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleTaskBlock
     */
    'public': boolean;
    /**
     * 
     * @type {AudienceIds}
     * @memberof SimpleTaskBlock
     */
    'audiences': AudienceIds;
}

export const SimpleTaskBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type SimpleTaskBlockVersionEnum = typeof SimpleTaskBlockVersionEnum[keyof typeof SimpleTaskBlockVersionEnum];
export const SimpleTaskBlockTypeEnum = {
    SimpleTask: 'simple_task'
} as const;

export type SimpleTaskBlockTypeEnum = typeof SimpleTaskBlockTypeEnum[keyof typeof SimpleTaskBlockTypeEnum];
export const SimpleTaskBlockCategoryEnum = {
    Accounting: 'Accounting',
    Safety: 'Safety',
    Training: 'Training',
    ContentRating: 'Content Rating',
    ContentAcceptance: 'Content Acceptance',
    Appearance: 'Appearance',
    Motivational: 'Motivational'
} as const;

export type SimpleTaskBlockCategoryEnum = typeof SimpleTaskBlockCategoryEnum[keyof typeof SimpleTaskBlockCategoryEnum];

/**
 * 
 * @export
 * @interface SimpleTaskBlockV1
 */
export interface SimpleTaskBlockV1 {
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlockV1
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlockV1
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlockV1
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlockV1
     */
    'version': SimpleTaskBlockV1VersionEnum;
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlockV1
     */
    'articleId': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskBlockV1
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskBlockV1
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskBlockV1
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskBlockV1
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskBlockV1
     */
    'type': SimpleTaskBlockV1TypeEnum;
    /**
     * 
     * @type {SimpleTaskBlockV1Variants}
     * @memberof SimpleTaskBlockV1
     */
    'variants': SimpleTaskBlockV1Variants;
    /**
     * 
     * @type {number}
     * @memberof SimpleTaskBlockV1
     */
    'required': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskBlockV1
     */
    'category': SimpleTaskBlockV1CategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskBlockV1
     */
    'deadline': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleTaskBlockV1
     */
    'public': boolean;
    /**
     * 
     * @type {AudienceIds}
     * @memberof SimpleTaskBlockV1
     */
    'audiences': AudienceIds;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleTaskBlockV1
     */
    'completed': boolean;
    /**
     * 
     * @type {UserAnswers}
     * @memberof SimpleTaskBlockV1
     */
    'currentUserAnswers': UserAnswers;
}

export const SimpleTaskBlockV1VersionEnum = {
    NUMBER_1: 1
} as const;

export type SimpleTaskBlockV1VersionEnum = typeof SimpleTaskBlockV1VersionEnum[keyof typeof SimpleTaskBlockV1VersionEnum];
export const SimpleTaskBlockV1TypeEnum = {
    SimpleTask: 'simple_task'
} as const;

export type SimpleTaskBlockV1TypeEnum = typeof SimpleTaskBlockV1TypeEnum[keyof typeof SimpleTaskBlockV1TypeEnum];
export const SimpleTaskBlockV1CategoryEnum = {
    Accounting: 'Accounting',
    Safety: 'Safety',
    Training: 'Training',
    ContentRating: 'Content Rating',
    ContentAcceptance: 'Content Acceptance',
    Appearance: 'Appearance',
    Motivational: 'Motivational'
} as const;

export type SimpleTaskBlockV1CategoryEnum = typeof SimpleTaskBlockV1CategoryEnum[keyof typeof SimpleTaskBlockV1CategoryEnum];

/**
 * 
 * @export
 * @interface SimpleTaskBlockV1Variants
 */
export interface SimpleTaskBlockV1Variants {
    [key: string]: SimpleTaskVariant;

}
/**
 * 
 * @export
 * @interface SimpleTaskBlockVariants
 */
export interface SimpleTaskBlockVariants {
    [key: string]: SimpleTaskVariant;

}
/**
 * 
 * @export
 * @interface SimpleTaskVariant
 */
export interface SimpleTaskVariant {
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskVariant
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleTaskVariant
     */
    'translationStatus': SimpleTaskVariantTranslationStatusEnum;
}

export const SimpleTaskVariantTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type SimpleTaskVariantTranslationStatusEnum = typeof SimpleTaskVariantTranslationStatusEnum[keyof typeof SimpleTaskVariantTranslationStatusEnum];

/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    'sharingConnectionId': number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Text
 */
export interface Text {
    /**
     * 
     * @type {string}
     * @memberof Text
     */
    'type': TextTypeEnum;
    /**
     * 
     * @type {TextFormat}
     * @memberof Text
     */
    'format': TextFormat;
    /**
     * 
     * @type {string}
     * @memberof Text
     */
    'value': string;
}

export const TextTypeEnum = {
    Text: 'text'
} as const;

export type TextTypeEnum = typeof TextTypeEnum[keyof typeof TextTypeEnum];

/**
 * 
 * @export
 * @interface TextBlock
 */
export interface TextBlock {
    /**
     * 
     * @type {number}
     * @memberof TextBlock
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TextBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof TextBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof TextBlock
     */
    'version': TextBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof TextBlock
     */
    'type': TextBlockTypeEnum;
    /**
     * 
     * @type {TextBlockVariants}
     * @memberof TextBlock
     */
    'variants': TextBlockVariants;
}

export const TextBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type TextBlockVersionEnum = typeof TextBlockVersionEnum[keyof typeof TextBlockVersionEnum];
export const TextBlockTypeEnum = {
    Text: 'text'
} as const;

export type TextBlockTypeEnum = typeof TextBlockTypeEnum[keyof typeof TextBlockTypeEnum];

/**
 * 
 * @export
 * @interface TextBlockV1
 */
export interface TextBlockV1 {
    /**
     * 
     * @type {number}
     * @memberof TextBlockV1
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof TextBlockV1
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof TextBlockV1
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof TextBlockV1
     */
    'version': TextBlockV1VersionEnum;
    /**
     * 
     * @type {number}
     * @memberof TextBlockV1
     */
    'articleId': number;
    /**
     * 
     * @type {string}
     * @memberof TextBlockV1
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TextBlockV1
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TextBlockV1
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof TextBlockV1
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof TextBlockV1
     */
    'type': TextBlockV1TypeEnum;
    /**
     * 
     * @type {TextBlockV1Variants}
     * @memberof TextBlockV1
     */
    'variants': TextBlockV1Variants;
}

export const TextBlockV1VersionEnum = {
    NUMBER_1: 1
} as const;

export type TextBlockV1VersionEnum = typeof TextBlockV1VersionEnum[keyof typeof TextBlockV1VersionEnum];
export const TextBlockV1TypeEnum = {
    Text: 'text'
} as const;

export type TextBlockV1TypeEnum = typeof TextBlockV1TypeEnum[keyof typeof TextBlockV1TypeEnum];

/**
 * 
 * @export
 * @interface TextBlockV1Variants
 */
export interface TextBlockV1Variants {
    [key: string]: TextBlockVariant;

}
/**
 * 
 * @export
 * @interface TextBlockVariant
 */
export interface TextBlockVariant {
    /**
     * 
     * @type {string}
     * @memberof TextBlockVariant
     */
    'translationStatus': TextBlockVariantTranslationStatusEnum;
    /**
     * 
     * @type {Array<TextVariantItem>}
     * @memberof TextBlockVariant
     */
    'items': Array<TextVariantItem>;
}

export const TextBlockVariantTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type TextBlockVariantTranslationStatusEnum = typeof TextBlockVariantTranslationStatusEnum[keyof typeof TextBlockVariantTranslationStatusEnum];

/**
 * 
 * @export
 * @interface TextBlockVariants
 */
export interface TextBlockVariants {
    [key: string]: TextBlockVariant;

}
/**
 * 
 * @export
 * @interface TextFormat
 */
export interface TextFormat {
    /**
     * 
     * @type {boolean}
     * @memberof TextFormat
     */
    'bold'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TextFormat
     */
    'italic'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TextFormat
     */
    'underline'?: boolean;
}
/**
 * @type TextOrLink
 * @export
 */
export type TextOrLink = { type: 'link' } & Link | { type: 'text' } & Text;

/**
 * @type TextVariantItem
 * @export
 */
export type TextVariantItem = { type: 'heading' } & Heading | { type: 'list' } & List | { type: 'paragraph' } & Paragraph;

/**
 * 
 * @export
 * @interface UnarchiveArticlesRequest
 */
export interface UnarchiveArticlesRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof UnarchiveArticlesRequest
     */
    'articleIds': Array<number>;
}
/**
 * 
 * @export
 * @interface UncompletedAction
 */
export interface UncompletedAction {
    /**
     * 
     * @type {number}
     * @memberof UncompletedAction
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UncompletedAction
     */
    'type': UncompletedActionTypeEnum;
    /**
     * 
     * @type {ActionVariants}
     * @memberof UncompletedAction
     */
    'variants': ActionVariants;
    /**
     * 
     * @type {number}
     * @memberof UncompletedAction
     */
    'required': number;
    /**
     * 
     * @type {string}
     * @memberof UncompletedAction
     */
    'category': UncompletedActionCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof UncompletedAction
     */
    'deadline': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UncompletedAction
     */
    'public': boolean;
    /**
     * 
     * @type {number}
     * @memberof UncompletedAction
     */
    'articleId': number;
    /**
     * 
     * @type {ArticleVariants}
     * @memberof UncompletedAction
     */
    'articleVariants': ArticleVariants;
    /**
     * 
     * @type {string}
     * @memberof UncompletedAction
     */
    'createdAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof UncompletedAction
     */
    'updatedAt': string | null;
}

export const UncompletedActionTypeEnum = {
    SimpleTask: 'simple_task',
    MediaTask: 'media_task'
} as const;

export type UncompletedActionTypeEnum = typeof UncompletedActionTypeEnum[keyof typeof UncompletedActionTypeEnum];
export const UncompletedActionCategoryEnum = {
    Accounting: 'Accounting',
    Safety: 'Safety',
    Training: 'Training',
    ContentRating: 'Content Rating',
    ContentAcceptance: 'Content Acceptance',
    Appearance: 'Appearance',
    Motivational: 'Motivational'
} as const;

export type UncompletedActionCategoryEnum = typeof UncompletedActionCategoryEnum[keyof typeof UncompletedActionCategoryEnum];

/**
 * 
 * @export
 * @interface UncompletedActionsPage
 */
export interface UncompletedActionsPage {
    /**
     * 
     * @type {ActionAnswerPageMeta}
     * @memberof UncompletedActionsPage
     */
    'meta': ActionAnswerPageMeta;
    /**
     * 
     * @type {Array<UncompletedAction>}
     * @memberof UncompletedActionsPage
     */
    'data': Array<UncompletedAction>;
}
/**
 * 
 * @export
 * @interface UnrchiveArticlesResponse
 */
export interface UnrchiveArticlesResponse extends Array<Article> {
}
/**
 * 
 * @export
 * @interface UpdatedArticle
 */
export interface UpdatedArticle {
    /**
     * 
     * @type {number}
     * @memberof UpdatedArticle
     */
    'id': number;
    /**
     * 
     * @type {ArticleVariants}
     * @memberof UpdatedArticle
     */
    'variants': ArticleVariants;
    /**
     * 
     * @type {string}
     * @memberof UpdatedArticle
     */
    'status': UpdatedArticleStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatedArticle
     */
    'publishAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdatedArticle
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {Array<UpdatedBlock>}
     * @memberof UpdatedArticle
     */
    'blocks': Array<UpdatedBlock>;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdatedArticle
     */
    'audiences': Array<number>;
    /**
     * 
     * @type {ArticleCollaborators}
     * @memberof UpdatedArticle
     */
    'users': ArticleCollaborators;
    /**
     * 
     * @type {Array<NewArticleLanguagesInner>}
     * @memberof UpdatedArticle
     */
    'languages': Array<NewArticleLanguagesInner>;
    /**
     * 
     * @type {number}
     * @memberof UpdatedArticle
     */
    'channelId': number | null;
}

export const UpdatedArticleStatusEnum = {
    Draft: 'draft',
    Published: 'published',
    Archived: 'archived',
    Inbound: 'inbound',
    Rejected: 'rejected'
} as const;

export type UpdatedArticleStatusEnum = typeof UpdatedArticleStatusEnum[keyof typeof UpdatedArticleStatusEnum];

/**
 * @type UpdatedBlock
 * @export
 */
export type UpdatedBlock = { type: 'image' } & ImageBlock | { type: 'media_task' } & MediaTaskBlock | { type: 'pdf' } & PdfBlock | { type: 'simple_task' } & SimpleTaskBlock | { type: 'text' } & TextBlock | { type: 'url' } & UrlBlock | { type: 'video' } & VideoBlock;

/**
 * 
 * @export
 * @interface UpdatedChannel
 */
export interface UpdatedChannel {
    /**
     * 
     * @type {number}
     * @memberof UpdatedChannel
     */
    'id': number;
    /**
     * 
     * @type {ChannelTitleTranslation}
     * @memberof UpdatedChannel
     */
    'title': ChannelTitleTranslation;
    /**
     * 
     * @type {CoverImageFile}
     * @memberof UpdatedChannel
     */
    'coverImage': CoverImageFile;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatedChannel
     */
    'pushNotification': boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdatedChannel
     */
    'ranking': number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatedChannel
     */
    'hideIfEmpty': boolean;
}
/**
 * 
 * @export
 * @interface UrlBlock
 */
export interface UrlBlock {
    /**
     * 
     * @type {number}
     * @memberof UrlBlock
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UrlBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof UrlBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof UrlBlock
     */
    'version': UrlBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof UrlBlock
     */
    'type': UrlBlockTypeEnum;
    /**
     * 
     * @type {UrlBlockVariants}
     * @memberof UrlBlock
     */
    'variants': UrlBlockVariants;
}

export const UrlBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type UrlBlockVersionEnum = typeof UrlBlockVersionEnum[keyof typeof UrlBlockVersionEnum];
export const UrlBlockTypeEnum = {
    Url: 'url'
} as const;

export type UrlBlockTypeEnum = typeof UrlBlockTypeEnum[keyof typeof UrlBlockTypeEnum];

/**
 * 
 * @export
 * @interface UrlBlockV1
 */
export interface UrlBlockV1 {
    /**
     * 
     * @type {number}
     * @memberof UrlBlockV1
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof UrlBlockV1
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof UrlBlockV1
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof UrlBlockV1
     */
    'version': UrlBlockV1VersionEnum;
    /**
     * 
     * @type {number}
     * @memberof UrlBlockV1
     */
    'articleId': number;
    /**
     * 
     * @type {string}
     * @memberof UrlBlockV1
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UrlBlockV1
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UrlBlockV1
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof UrlBlockV1
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof UrlBlockV1
     */
    'type': UrlBlockV1TypeEnum;
    /**
     * 
     * @type {UrlBlockV1Variants}
     * @memberof UrlBlockV1
     */
    'variants': UrlBlockV1Variants;
}

export const UrlBlockV1VersionEnum = {
    NUMBER_1: 1
} as const;

export type UrlBlockV1VersionEnum = typeof UrlBlockV1VersionEnum[keyof typeof UrlBlockV1VersionEnum];
export const UrlBlockV1TypeEnum = {
    Url: 'url'
} as const;

export type UrlBlockV1TypeEnum = typeof UrlBlockV1TypeEnum[keyof typeof UrlBlockV1TypeEnum];

/**
 * 
 * @export
 * @interface UrlBlockV1Variants
 */
export interface UrlBlockV1Variants {
    [key: string]: UrlVariant;

}
/**
 * 
 * @export
 * @interface UrlBlockVariants
 */
export interface UrlBlockVariants {
    [key: string]: UrlVariant;

}
/**
 * 
 * @export
 * @interface UrlVariant
 */
export interface UrlVariant {
    /**
     * 
     * @type {string}
     * @memberof UrlVariant
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof UrlVariant
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UrlVariant
     */
    'openIn': UrlVariantOpenInEnum;
    /**
     * 
     * @type {string}
     * @memberof UrlVariant
     */
    'translationStatus': UrlVariantTranslationStatusEnum;
}

export const UrlVariantOpenInEnum = {
    CurrentWindow: 'current-window',
    NewWindow: 'new-window'
} as const;

export type UrlVariantOpenInEnum = typeof UrlVariantOpenInEnum[keyof typeof UrlVariantOpenInEnum];
export const UrlVariantTranslationStatusEnum = {
    Draft: 'draft',
    Approved: 'approved'
} as const;

export type UrlVariantTranslationStatusEnum = typeof UrlVariantTranslationStatusEnum[keyof typeof UrlVariantTranslationStatusEnum];

/**
 * 
 * @export
 * @interface UserAnswer
 */
export interface UserAnswer {
    /**
     * 
     * @type {number}
     * @memberof UserAnswer
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserAnswer
     */
    'answer': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAnswer
     */
    'correct': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserAnswer
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserAnswer
     */
    'revertedAt': string | null;
    /**
     * 
     * @type {number}
     * @memberof UserAnswer
     */
    'revertedBy': number | null;
}
/**
 * 
 * @export
 * @interface UserAnswers
 */
export interface UserAnswers extends Array<UserAnswer> {
}
/**
 * 
 * @export
 * @interface ValidationIssue
 */
export interface ValidationIssue {
    /**
     * 
     * @type {string}
     * @memberof ValidationIssue
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ValidationIssues
 */
export interface ValidationIssues extends Array<ValidationIssue> {
}
/**
 * 
 * @export
 * @interface VideoBlock
 */
export interface VideoBlock {
    /**
     * 
     * @type {number}
     * @memberof VideoBlock
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof VideoBlock
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof VideoBlock
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof VideoBlock
     */
    'version': VideoBlockVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof VideoBlock
     */
    'type': VideoBlockTypeEnum;
    /**
     * 
     * @type {VideoBlockVariants}
     * @memberof VideoBlock
     */
    'variants': VideoBlockVariants;
}

export const VideoBlockVersionEnum = {
    NUMBER_1: 1
} as const;

export type VideoBlockVersionEnum = typeof VideoBlockVersionEnum[keyof typeof VideoBlockVersionEnum];
export const VideoBlockTypeEnum = {
    Video: 'video'
} as const;

export type VideoBlockTypeEnum = typeof VideoBlockTypeEnum[keyof typeof VideoBlockTypeEnum];

/**
 * 
 * @export
 * @interface VideoBlockV1
 */
export interface VideoBlockV1 {
    /**
     * 
     * @type {number}
     * @memberof VideoBlockV1
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof VideoBlockV1
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof VideoBlockV1
     */
    'parentId': number | null;
    /**
     * 
     * @type {number}
     * @memberof VideoBlockV1
     */
    'version': VideoBlockV1VersionEnum;
    /**
     * 
     * @type {number}
     * @memberof VideoBlockV1
     */
    'articleId': number;
    /**
     * 
     * @type {string}
     * @memberof VideoBlockV1
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof VideoBlockV1
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof VideoBlockV1
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoBlockV1
     */
    'archiveAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoBlockV1
     */
    'type': VideoBlockV1TypeEnum;
    /**
     * 
     * @type {VideoBlockV1Variants}
     * @memberof VideoBlockV1
     */
    'variants': VideoBlockV1Variants;
}

export const VideoBlockV1VersionEnum = {
    NUMBER_1: 1
} as const;

export type VideoBlockV1VersionEnum = typeof VideoBlockV1VersionEnum[keyof typeof VideoBlockV1VersionEnum];
export const VideoBlockV1TypeEnum = {
    Video: 'video'
} as const;

export type VideoBlockV1TypeEnum = typeof VideoBlockV1TypeEnum[keyof typeof VideoBlockV1TypeEnum];

/**
 * 
 * @export
 * @interface VideoBlockV1Variants
 */
export interface VideoBlockV1Variants {
    [key: string]: ArticleFileGet;

}
/**
 * 
 * @export
 * @interface VideoBlockVariants
 */
export interface VideoBlockVariants {
    [key: string]: FileVariant;

}

/**
 * ActionAnswerApi - axios parameter creator
 * @export
 */
export const ActionAnswerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Submit action answer
         * @param {number} actionId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionAnswer: async (actionId: number, page?: number, perPage?: number, mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('getActionAnswer', 'actionId', actionId)
            const localVarPath = `/action/answer/{actionId}`
                .replace(`{${"actionId"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit action answer
         * @param {boolean} [mock] 
         * @param {NewActionAnswer} [newActionAnswer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postActionAnswer: async (mock?: boolean, newActionAnswer?: NewActionAnswer, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/action/answer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newActionAnswer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionAnswerApi - functional programming interface
 * @export
 */
export const ActionAnswerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionAnswerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Submit action answer
         * @param {number} actionId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionAnswer(actionId: number, page?: number, perPage?: number, mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionAnswerPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionAnswer(actionId, page, perPage, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit action answer
         * @param {boolean} [mock] 
         * @param {NewActionAnswer} [newActionAnswer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postActionAnswer(mock?: boolean, newActionAnswer?: NewActionAnswer, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAnswer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postActionAnswer(mock, newActionAnswer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActionAnswerApi - factory interface
 * @export
 */
export const ActionAnswerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionAnswerApiFp(configuration)
    return {
        /**
         * 
         * @summary Submit action answer
         * @param {number} actionId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionAnswer(actionId: number, page?: number, perPage?: number, mock?: boolean, options?: any): AxiosPromise<ActionAnswerPage> {
            return localVarFp.getActionAnswer(actionId, page, perPage, mock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit action answer
         * @param {boolean} [mock] 
         * @param {NewActionAnswer} [newActionAnswer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postActionAnswer(mock?: boolean, newActionAnswer?: NewActionAnswer, options?: any): AxiosPromise<UserAnswer> {
            return localVarFp.postActionAnswer(mock, newActionAnswer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionAnswerApi - object-oriented interface
 * @export
 * @class ActionAnswerApi
 * @extends {BaseAPI}
 */
export class ActionAnswerApi extends BaseAPI {
    /**
     * 
     * @summary Submit action answer
     * @param {number} actionId 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAnswerApi
     */
    public getActionAnswer(actionId: number, page?: number, perPage?: number, mock?: boolean, options?: AxiosRequestConfig) {
        return ActionAnswerApiFp(this.configuration).getActionAnswer(actionId, page, perPage, mock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit action answer
     * @param {boolean} [mock] 
     * @param {NewActionAnswer} [newActionAnswer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAnswerApi
     */
    public postActionAnswer(mock?: boolean, newActionAnswer?: NewActionAnswer, options?: AxiosRequestConfig) {
        return ActionAnswerApiFp(this.configuration).postActionAnswer(mock, newActionAnswer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArchiveArticleApi - axios parameter creator
 * @export
 */
export const ArchiveArticleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive articles
         * @param {boolean} [mock] 
         * @param {ArchiveArticlesRequest} [archiveArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveArticle: async (mock?: boolean, archiveArticlesRequest?: ArchiveArticlesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/archive-article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(archiveArticlesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unarchive articles
         * @param {boolean} [mock] 
         * @param {UnarchiveArticlesRequest} [unarchiveArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveArticle: async (mock?: boolean, unarchiveArticlesRequest?: UnarchiveArticlesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/unarchive-article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unarchiveArticlesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArchiveArticleApi - functional programming interface
 * @export
 */
export const ArchiveArticleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArchiveArticleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Archive articles
         * @param {boolean} [mock] 
         * @param {ArchiveArticlesRequest} [archiveArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveArticle(mock?: boolean, archiveArticlesRequest?: ArchiveArticlesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArchiveArticlesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveArticle(mock, archiveArticlesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unarchive articles
         * @param {boolean} [mock] 
         * @param {UnarchiveArticlesRequest} [unarchiveArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveArticle(mock?: boolean, unarchiveArticlesRequest?: UnarchiveArticlesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnrchiveArticlesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveArticle(mock, unarchiveArticlesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArchiveArticleApi - factory interface
 * @export
 */
export const ArchiveArticleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArchiveArticleApiFp(configuration)
    return {
        /**
         * 
         * @summary Archive articles
         * @param {boolean} [mock] 
         * @param {ArchiveArticlesRequest} [archiveArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveArticle(mock?: boolean, archiveArticlesRequest?: ArchiveArticlesRequest, options?: any): AxiosPromise<ArchiveArticlesResponse> {
            return localVarFp.archiveArticle(mock, archiveArticlesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unarchive articles
         * @param {boolean} [mock] 
         * @param {UnarchiveArticlesRequest} [unarchiveArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveArticle(mock?: boolean, unarchiveArticlesRequest?: UnarchiveArticlesRequest, options?: any): AxiosPromise<UnrchiveArticlesResponse> {
            return localVarFp.unarchiveArticle(mock, unarchiveArticlesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArchiveArticleApi - object-oriented interface
 * @export
 * @class ArchiveArticleApi
 * @extends {BaseAPI}
 */
export class ArchiveArticleApi extends BaseAPI {
    /**
     * 
     * @summary Archive articles
     * @param {boolean} [mock] 
     * @param {ArchiveArticlesRequest} [archiveArticlesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveArticleApi
     */
    public archiveArticle(mock?: boolean, archiveArticlesRequest?: ArchiveArticlesRequest, options?: AxiosRequestConfig) {
        return ArchiveArticleApiFp(this.configuration).archiveArticle(mock, archiveArticlesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unarchive articles
     * @param {boolean} [mock] 
     * @param {UnarchiveArticlesRequest} [unarchiveArticlesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveArticleApi
     */
    public unarchiveArticle(mock?: boolean, unarchiveArticlesRequest?: UnarchiveArticlesRequest, options?: AxiosRequestConfig) {
        return ArchiveArticleApiFp(this.configuration).unarchiveArticle(mock, unarchiveArticlesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArticleApi - axios parameter creator
 * @export
 */
export const ArticleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create article
         * @param {boolean} [mock] 
         * @param {NewArticle} [newArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewArticle: async (mock?: boolean, newArticle?: NewArticle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newArticle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete single article
         * @param {number} articleId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticle: async (articleId: number, mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('deleteArticle', 'articleId', articleId)
            const localVarPath = `/article/{articleId}`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get article
         * @param {number} articleId 
         * @param {string} [include] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticle: async (articleId: number, include?: string, mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('getArticle', 'articleId', articleId)
            const localVarPath = `/article/{articleId}`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get articles
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [title] 
         * @param {'draft' | 'published' | 'archived' | 'inbound' | 'rejected'} [status] 
         * @param {number} [createdBy] 
         * @param {string} [channelId] 
         * @param {'1'} [live] 
         * @param {'1'} [unseen] 
         * @param {string} [timezone] 
         * @param {'asc' | 'desc'} [archiveAt] 
         * @param {'asc' | 'desc'} [createdAt] 
         * @param {'asc' | 'desc'} [publishAt] 
         * @param {'asc' | 'desc'} [updatedAt] 
         * @param {string} [include] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticlePage: async (page?: number, perPage?: number, title?: string, status?: 'draft' | 'published' | 'archived' | 'inbound' | 'rejected', createdBy?: number, channelId?: string, live?: '1', unseen?: '1', timezone?: string, archiveAt?: 'asc' | 'desc', createdAt?: 'asc' | 'desc', publishAt?: 'asc' | 'desc', updatedAt?: 'asc' | 'desc', include?: string, mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['createdBy'] = createdBy;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }

            if (unseen !== undefined) {
                localVarQueryParameter['unseen'] = unseen;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (archiveAt !== undefined) {
                localVarQueryParameter['archiveAt'] = archiveAt;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (publishAt !== undefined) {
                localVarQueryParameter['publishAt'] = publishAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update article
         * @param {boolean} [mock] 
         * @param {UpdatedArticle} [updatedArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticle: async (mock?: boolean, updatedArticle?: UpdatedArticle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatedArticle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArticleApi - functional programming interface
 * @export
 */
export const ArticleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArticleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create article
         * @param {boolean} [mock] 
         * @param {NewArticle} [newArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewArticle(mock?: boolean, newArticle?: NewArticle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Article>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewArticle(mock, newArticle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete single article
         * @param {number} articleId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArticle(articleId: number, mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArticle(articleId, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get article
         * @param {number} articleId 
         * @param {string} [include] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticle(articleId: number, include?: string, mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Article>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArticle(articleId, include, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get articles
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [title] 
         * @param {'draft' | 'published' | 'archived' | 'inbound' | 'rejected'} [status] 
         * @param {number} [createdBy] 
         * @param {string} [channelId] 
         * @param {'1'} [live] 
         * @param {'1'} [unseen] 
         * @param {string} [timezone] 
         * @param {'asc' | 'desc'} [archiveAt] 
         * @param {'asc' | 'desc'} [createdAt] 
         * @param {'asc' | 'desc'} [publishAt] 
         * @param {'asc' | 'desc'} [updatedAt] 
         * @param {string} [include] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticlePage(page?: number, perPage?: number, title?: string, status?: 'draft' | 'published' | 'archived' | 'inbound' | 'rejected', createdBy?: number, channelId?: string, live?: '1', unseen?: '1', timezone?: string, archiveAt?: 'asc' | 'desc', createdAt?: 'asc' | 'desc', publishAt?: 'asc' | 'desc', updatedAt?: 'asc' | 'desc', include?: string, mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticlePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArticlePage(page, perPage, title, status, createdBy, channelId, live, unseen, timezone, archiveAt, createdAt, publishAt, updatedAt, include, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update article
         * @param {boolean} [mock] 
         * @param {UpdatedArticle} [updatedArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArticle(mock?: boolean, updatedArticle?: UpdatedArticle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Article>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArticle(mock, updatedArticle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArticleApi - factory interface
 * @export
 */
export const ArticleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArticleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create article
         * @param {boolean} [mock] 
         * @param {NewArticle} [newArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewArticle(mock?: boolean, newArticle?: NewArticle, options?: any): AxiosPromise<Article> {
            return localVarFp.createNewArticle(mock, newArticle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete single article
         * @param {number} articleId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticle(articleId: number, mock?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.deleteArticle(articleId, mock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get article
         * @param {number} articleId 
         * @param {string} [include] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticle(articleId: number, include?: string, mock?: boolean, options?: any): AxiosPromise<Article> {
            return localVarFp.getArticle(articleId, include, mock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get articles
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [title] 
         * @param {'draft' | 'published' | 'archived' | 'inbound' | 'rejected'} [status] 
         * @param {number} [createdBy] 
         * @param {string} [channelId] 
         * @param {'1'} [live] 
         * @param {'1'} [unseen] 
         * @param {string} [timezone] 
         * @param {'asc' | 'desc'} [archiveAt] 
         * @param {'asc' | 'desc'} [createdAt] 
         * @param {'asc' | 'desc'} [publishAt] 
         * @param {'asc' | 'desc'} [updatedAt] 
         * @param {string} [include] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticlePage(page?: number, perPage?: number, title?: string, status?: 'draft' | 'published' | 'archived' | 'inbound' | 'rejected', createdBy?: number, channelId?: string, live?: '1', unseen?: '1', timezone?: string, archiveAt?: 'asc' | 'desc', createdAt?: 'asc' | 'desc', publishAt?: 'asc' | 'desc', updatedAt?: 'asc' | 'desc', include?: string, mock?: boolean, options?: any): AxiosPromise<ArticlePage> {
            return localVarFp.getArticlePage(page, perPage, title, status, createdBy, channelId, live, unseen, timezone, archiveAt, createdAt, publishAt, updatedAt, include, mock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update article
         * @param {boolean} [mock] 
         * @param {UpdatedArticle} [updatedArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticle(mock?: boolean, updatedArticle?: UpdatedArticle, options?: any): AxiosPromise<Article> {
            return localVarFp.updateArticle(mock, updatedArticle, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArticleApi - object-oriented interface
 * @export
 * @class ArticleApi
 * @extends {BaseAPI}
 */
export class ArticleApi extends BaseAPI {
    /**
     * 
     * @summary Create article
     * @param {boolean} [mock] 
     * @param {NewArticle} [newArticle] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleApi
     */
    public createNewArticle(mock?: boolean, newArticle?: NewArticle, options?: AxiosRequestConfig) {
        return ArticleApiFp(this.configuration).createNewArticle(mock, newArticle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete single article
     * @param {number} articleId 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleApi
     */
    public deleteArticle(articleId: number, mock?: boolean, options?: AxiosRequestConfig) {
        return ArticleApiFp(this.configuration).deleteArticle(articleId, mock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get article
     * @param {number} articleId 
     * @param {string} [include] 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleApi
     */
    public getArticle(articleId: number, include?: string, mock?: boolean, options?: AxiosRequestConfig) {
        return ArticleApiFp(this.configuration).getArticle(articleId, include, mock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get articles
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [title] 
     * @param {'draft' | 'published' | 'archived' | 'inbound' | 'rejected'} [status] 
     * @param {number} [createdBy] 
     * @param {string} [channelId] 
     * @param {'1'} [live] 
     * @param {'1'} [unseen] 
     * @param {string} [timezone] 
     * @param {'asc' | 'desc'} [archiveAt] 
     * @param {'asc' | 'desc'} [createdAt] 
     * @param {'asc' | 'desc'} [publishAt] 
     * @param {'asc' | 'desc'} [updatedAt] 
     * @param {string} [include] 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleApi
     */
    public getArticlePage(page?: number, perPage?: number, title?: string, status?: 'draft' | 'published' | 'archived' | 'inbound' | 'rejected', createdBy?: number, channelId?: string, live?: '1', unseen?: '1', timezone?: string, archiveAt?: 'asc' | 'desc', createdAt?: 'asc' | 'desc', publishAt?: 'asc' | 'desc', updatedAt?: 'asc' | 'desc', include?: string, mock?: boolean, options?: AxiosRequestConfig) {
        return ArticleApiFp(this.configuration).getArticlePage(page, perPage, title, status, createdBy, channelId, live, unseen, timezone, archiveAt, createdAt, publishAt, updatedAt, include, mock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update article
     * @param {boolean} [mock] 
     * @param {UpdatedArticle} [updatedArticle] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleApi
     */
    public updateArticle(mock?: boolean, updatedArticle?: UpdatedArticle, options?: AxiosRequestConfig) {
        return ArticleApiFp(this.configuration).updateArticle(mock, updatedArticle, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChangeLogApi - axios parameter creator
 * @export
 */
export const ChangeLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Changelog
         * @param {number} articleId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [userId] 
         * @param {'asc' | 'desc'} [timestamp] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeLog: async (articleId: number, page?: number, perPage?: number, userId?: string, timestamp?: 'asc' | 'desc', mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('getChangeLog', 'articleId', articleId)
            const localVarPath = `/changelog/{articleId}`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChangeLogApi - functional programming interface
 * @export
 */
export const ChangeLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChangeLogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Changelog
         * @param {number} articleId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [userId] 
         * @param {'asc' | 'desc'} [timestamp] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChangeLog(articleId: number, page?: number, perPage?: number, userId?: string, timestamp?: 'asc' | 'desc', mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangelogPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChangeLog(articleId, page, perPage, userId, timestamp, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChangeLogApi - factory interface
 * @export
 */
export const ChangeLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChangeLogApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Changelog
         * @param {number} articleId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [userId] 
         * @param {'asc' | 'desc'} [timestamp] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeLog(articleId: number, page?: number, perPage?: number, userId?: string, timestamp?: 'asc' | 'desc', mock?: boolean, options?: any): AxiosPromise<ChangelogPage> {
            return localVarFp.getChangeLog(articleId, page, perPage, userId, timestamp, mock, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChangeLogApi - object-oriented interface
 * @export
 * @class ChangeLogApi
 * @extends {BaseAPI}
 */
export class ChangeLogApi extends BaseAPI {
    /**
     * 
     * @summary Get Changelog
     * @param {number} articleId 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [userId] 
     * @param {'asc' | 'desc'} [timestamp] 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeLogApi
     */
    public getChangeLog(articleId: number, page?: number, perPage?: number, userId?: string, timestamp?: 'asc' | 'desc', mock?: boolean, options?: AxiosRequestConfig) {
        return ChangeLogApiFp(this.configuration).getChangeLog(articleId, page, perPage, userId, timestamp, mock, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChannelApi - axios parameter creator
 * @export
 */
export const ChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create channel
         * @param {boolean} [mock] 
         * @param {NewChannel} [newChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewChannel: async (mock?: boolean, newChannel?: NewChannel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete single channel
         * @param {number} channelId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel: async (channelId: number, mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteChannel', 'channelId', channelId)
            const localVarPath = `/channel/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel
         * @param {number} channelId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel: async (channelId: number, mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getChannel', 'channelId', channelId)
            const localVarPath = `/channel/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channels
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {'asc' | 'desc'} [ranking] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelPage: async (page?: number, perPage?: number, ranking?: 'asc' | 'desc', mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (ranking !== undefined) {
                localVarQueryParameter['ranking'] = ranking;
            }

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update channel
         * @param {boolean} [mock] 
         * @param {UpdatedChannel} [updatedChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChannel: async (mock?: boolean, updatedChannel?: UpdatedChannel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatedChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelApi - functional programming interface
 * @export
 */
export const ChannelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create channel
         * @param {boolean} [mock] 
         * @param {NewChannel} [newChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewChannel(mock?: boolean, newChannel?: NewChannel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicChannelInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewChannel(mock, newChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete single channel
         * @param {number} channelId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannel(channelId: number, mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChannel(channelId, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get channel
         * @param {number} channelId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel(channelId: number, mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicChannelInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannel(channelId, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get channels
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {'asc' | 'desc'} [ranking] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelPage(page?: number, perPage?: number, ranking?: 'asc' | 'desc', mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelPage(page, perPage, ranking, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update channel
         * @param {boolean} [mock] 
         * @param {UpdatedChannel} [updatedChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChannel(mock?: boolean, updatedChannel?: UpdatedChannel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicChannelInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChannel(mock, updatedChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChannelApi - factory interface
 * @export
 */
export const ChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelApiFp(configuration)
    return {
        /**
         * 
         * @summary Create channel
         * @param {boolean} [mock] 
         * @param {NewChannel} [newChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewChannel(mock?: boolean, newChannel?: NewChannel, options?: any): AxiosPromise<BasicChannelInfo> {
            return localVarFp.createNewChannel(mock, newChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete single channel
         * @param {number} channelId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(channelId: number, mock?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.deleteChannel(channelId, mock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel
         * @param {number} channelId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelId: number, mock?: boolean, options?: any): AxiosPromise<BasicChannelInfo> {
            return localVarFp.getChannel(channelId, mock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channels
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {'asc' | 'desc'} [ranking] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelPage(page?: number, perPage?: number, ranking?: 'asc' | 'desc', mock?: boolean, options?: any): AxiosPromise<ChannelPage> {
            return localVarFp.getChannelPage(page, perPage, ranking, mock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update channel
         * @param {boolean} [mock] 
         * @param {UpdatedChannel} [updatedChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChannel(mock?: boolean, updatedChannel?: UpdatedChannel, options?: any): AxiosPromise<BasicChannelInfo> {
            return localVarFp.updateChannel(mock, updatedChannel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
export class ChannelApi extends BaseAPI {
    /**
     * 
     * @summary Create channel
     * @param {boolean} [mock] 
     * @param {NewChannel} [newChannel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public createNewChannel(mock?: boolean, newChannel?: NewChannel, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).createNewChannel(mock, newChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete single channel
     * @param {number} channelId 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public deleteChannel(channelId: number, mock?: boolean, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).deleteChannel(channelId, mock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel
     * @param {number} channelId 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getChannel(channelId: number, mock?: boolean, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).getChannel(channelId, mock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channels
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {'asc' | 'desc'} [ranking] 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getChannelPage(page?: number, perPage?: number, ranking?: 'asc' | 'desc', mock?: boolean, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).getChannelPage(page, perPage, ranking, mock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update channel
     * @param {boolean} [mock] 
     * @param {UpdatedChannel} [updatedChannel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public updateChannel(mock?: boolean, updatedChannel?: UpdatedChannel, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).updateChannel(mock, updatedChannel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Submit event
         * @param {boolean} [mock] 
         * @param {NewEvent} [newEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEvent: async (mock?: boolean, newEvent?: NewEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Submit event
         * @param {boolean} [mock] 
         * @param {NewEvent} [newEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postEvent(mock?: boolean, newEvent?: NewEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postEvent(mock, newEvent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * 
         * @summary Submit event
         * @param {boolean} [mock] 
         * @param {NewEvent} [newEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEvent(mock?: boolean, newEvent?: NewEvent, options?: any): AxiosPromise<void> {
            return localVarFp.postEvent(mock, newEvent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary Submit event
     * @param {boolean} [mock] 
     * @param {NewEvent} [newEvent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public postEvent(mock?: boolean, newEvent?: NewEvent, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).postEvent(mock, newEvent, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a file slot
         * @param {boolean} [mock] 
         * @param {FileSlot} [fileSlot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileSlot: async (mock?: boolean, fileSlot?: FileSlot, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/file/slot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileSlot, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file
         * @param {string} fileTenant 
         * @param {string} fileId 
         * @param {string} fileName 
         * @param {'redirect' | 'url'} [response] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (fileTenant: string, fileId: string, fileName: string, response?: 'redirect' | 'url', mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileTenant' is not null or undefined
            assertParamExists('getFile', 'fileTenant', fileTenant)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFile', 'fileId', fileId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getFile', 'fileName', fileName)
            const localVarPath = `/file/{fileTenant}/{fileId}/{fileName}`
                .replace(`{${"fileTenant"}}`, encodeURIComponent(String(fileTenant)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (response !== undefined) {
                localVarQueryParameter['response'] = response;
            }

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a file slot
         * @param {boolean} [mock] 
         * @param {FileSlot} [fileSlot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFileSlot(mock?: boolean, fileSlot?: FileSlot, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedFileSlot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFileSlot(mock, fileSlot, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a file
         * @param {string} fileTenant 
         * @param {string} fileId 
         * @param {string} fileName 
         * @param {'redirect' | 'url'} [response] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(fileTenant: string, fileId: string, fileName: string, response?: 'redirect' | 'url', mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(fileTenant, fileId, fileName, response, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a file slot
         * @param {boolean} [mock] 
         * @param {FileSlot} [fileSlot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileSlot(mock?: boolean, fileSlot?: FileSlot, options?: any): AxiosPromise<CreatedFileSlot> {
            return localVarFp.createFileSlot(mock, fileSlot, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file
         * @param {string} fileTenant 
         * @param {string} fileId 
         * @param {string} fileName 
         * @param {'redirect' | 'url'} [response] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileTenant: string, fileId: string, fileName: string, response?: 'redirect' | 'url', mock?: boolean, options?: any): AxiosPromise<GetFile200Response> {
            return localVarFp.getFile(fileTenant, fileId, fileName, response, mock, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * 
     * @summary Create a file slot
     * @param {boolean} [mock] 
     * @param {FileSlot} [fileSlot] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public createFileSlot(mock?: boolean, fileSlot?: FileSlot, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).createFileSlot(mock, fileSlot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file
     * @param {string} fileTenant 
     * @param {string} fileId 
     * @param {string} fileName 
     * @param {'redirect' | 'url'} [response] 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getFile(fileTenant: string, fileId: string, fileName: string, response?: 'redirect' | 'url', mock?: boolean, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).getFile(fileTenant, fileId, fileName, response, mock, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RelevantChannelApi - axios parameter creator
 * @export
 */
export const RelevantChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get relevant channels
         * @param {string} timezone 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {'asc' | 'desc'} [ranking] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelevantChannelPage: async (timezone: string, page?: number, perPage?: number, ranking?: 'asc' | 'desc', mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timezone' is not null or undefined
            assertParamExists('getRelevantChannelPage', 'timezone', timezone)
            const localVarPath = `/relevant-channel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (ranking !== undefined) {
                localVarQueryParameter['ranking'] = ranking;
            }

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelevantChannelApi - functional programming interface
 * @export
 */
export const RelevantChannelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelevantChannelApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get relevant channels
         * @param {string} timezone 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {'asc' | 'desc'} [ranking] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelevantChannelPage(timezone: string, page?: number, perPage?: number, ranking?: 'asc' | 'desc', mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelevantChannelPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelevantChannelPage(timezone, page, perPage, ranking, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RelevantChannelApi - factory interface
 * @export
 */
export const RelevantChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelevantChannelApiFp(configuration)
    return {
        /**
         * 
         * @summary Get relevant channels
         * @param {string} timezone 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {'asc' | 'desc'} [ranking] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelevantChannelPage(timezone: string, page?: number, perPage?: number, ranking?: 'asc' | 'desc', mock?: boolean, options?: any): AxiosPromise<RelevantChannelPage> {
            return localVarFp.getRelevantChannelPage(timezone, page, perPage, ranking, mock, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RelevantChannelApi - object-oriented interface
 * @export
 * @class RelevantChannelApi
 * @extends {BaseAPI}
 */
export class RelevantChannelApi extends BaseAPI {
    /**
     * 
     * @summary Get relevant channels
     * @param {string} timezone 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {'asc' | 'desc'} [ranking] 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelevantChannelApi
     */
    public getRelevantChannelPage(timezone: string, page?: number, perPage?: number, ranking?: 'asc' | 'desc', mock?: boolean, options?: AxiosRequestConfig) {
        return RelevantChannelApiFp(this.configuration).getRelevantChannelPage(timezone, page, perPage, ranking, mock, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RevertActionApi - axios parameter creator
 * @export
 */
export const RevertActionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Revert answers of all users
         * @param {boolean} [mock] 
         * @param {RevertAction} [revertAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revertAction: async (mock?: boolean, revertAction?: RevertAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/revert-action`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revertAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RevertActionApi - functional programming interface
 * @export
 */
export const RevertActionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RevertActionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Revert answers of all users
         * @param {boolean} [mock] 
         * @param {RevertAction} [revertAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revertAction(mock?: boolean, revertAction?: RevertAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revertAction(mock, revertAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RevertActionApi - factory interface
 * @export
 */
export const RevertActionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RevertActionApiFp(configuration)
    return {
        /**
         * 
         * @summary Revert answers of all users
         * @param {boolean} [mock] 
         * @param {RevertAction} [revertAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revertAction(mock?: boolean, revertAction?: RevertAction, options?: any): AxiosPromise<string> {
            return localVarFp.revertAction(mock, revertAction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RevertActionApi - object-oriented interface
 * @export
 * @class RevertActionApi
 * @extends {BaseAPI}
 */
export class RevertActionApi extends BaseAPI {
    /**
     * 
     * @summary Revert answers of all users
     * @param {boolean} [mock] 
     * @param {RevertAction} [revertAction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevertActionApi
     */
    public revertAction(mock?: boolean, revertAction?: RevertAction, options?: AxiosRequestConfig) {
        return RevertActionApiFp(this.configuration).revertAction(mock, revertAction, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RevertAnswerApi - axios parameter creator
 * @export
 */
export const RevertAnswerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Revert answer
         * @param {boolean} [mock] 
         * @param {RevertAnswer} [revertAnswer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revertAnswer: async (mock?: boolean, revertAnswer?: RevertAnswer, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/revert-answer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revertAnswer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RevertAnswerApi - functional programming interface
 * @export
 */
export const RevertAnswerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RevertAnswerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Revert answer
         * @param {boolean} [mock] 
         * @param {RevertAnswer} [revertAnswer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revertAnswer(mock?: boolean, revertAnswer?: RevertAnswer, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revertAnswer(mock, revertAnswer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RevertAnswerApi - factory interface
 * @export
 */
export const RevertAnswerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RevertAnswerApiFp(configuration)
    return {
        /**
         * 
         * @summary Revert answer
         * @param {boolean} [mock] 
         * @param {RevertAnswer} [revertAnswer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revertAnswer(mock?: boolean, revertAnswer?: RevertAnswer, options?: any): AxiosPromise<string> {
            return localVarFp.revertAnswer(mock, revertAnswer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RevertAnswerApi - object-oriented interface
 * @export
 * @class RevertAnswerApi
 * @extends {BaseAPI}
 */
export class RevertAnswerApi extends BaseAPI {
    /**
     * 
     * @summary Revert answer
     * @param {boolean} [mock] 
     * @param {RevertAnswer} [revertAnswer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevertAnswerApi
     */
    public revertAnswer(mock?: boolean, revertAnswer?: RevertAnswer, options?: AxiosRequestConfig) {
        return RevertAnswerApiFp(this.configuration).revertAnswer(mock, revertAnswer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SharedContentApi - axios parameter creator
 * @export
 */
export const SharedContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stop sharing article
         * @param {boolean} [mock] 
         * @param {DeleteSharedArticleRequest} [deleteSharedArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSharedArticle: async (mock?: boolean, deleteSharedArticleRequest?: DeleteSharedArticleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/sharing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteSharedArticleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get article sharing status overview
         * @param {number} articleId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleSharingStatusOverview: async (articleId: number, mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('getArticleSharingStatusOverview', 'articleId', articleId)
            const localVarPath = `/content/sharing/{articleId}`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share article
         * @param {boolean} [mock] 
         * @param {ShareArticleRequest} [shareArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArticle: async (mock?: boolean, shareArticleRequest?: ShareArticleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/sharing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareArticleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedContentApi - functional programming interface
 * @export
 */
export const SharedContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SharedContentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Stop sharing article
         * @param {boolean} [mock] 
         * @param {DeleteSharedArticleRequest} [deleteSharedArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSharedArticle(mock?: boolean, deleteSharedArticleRequest?: DeleteSharedArticleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSharedArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSharedArticle(mock, deleteSharedArticleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get article sharing status overview
         * @param {number} articleId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticleSharingStatusOverview(articleId: number, mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharingStatusOverviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArticleSharingStatusOverview(articleId, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Share article
         * @param {boolean} [mock] 
         * @param {ShareArticleRequest} [shareArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareArticle(mock?: boolean, shareArticleRequest?: ShareArticleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareArticle(mock, shareArticleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SharedContentApi - factory interface
 * @export
 */
export const SharedContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SharedContentApiFp(configuration)
    return {
        /**
         * 
         * @summary Stop sharing article
         * @param {boolean} [mock] 
         * @param {DeleteSharedArticleRequest} [deleteSharedArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSharedArticle(mock?: boolean, deleteSharedArticleRequest?: DeleteSharedArticleRequest, options?: any): AxiosPromise<DeleteSharedArticleResponse> {
            return localVarFp.deleteSharedArticle(mock, deleteSharedArticleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get article sharing status overview
         * @param {number} articleId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleSharingStatusOverview(articleId: number, mock?: boolean, options?: any): AxiosPromise<SharingStatusOverviewResponse> {
            return localVarFp.getArticleSharingStatusOverview(articleId, mock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share article
         * @param {boolean} [mock] 
         * @param {ShareArticleRequest} [shareArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArticle(mock?: boolean, shareArticleRequest?: ShareArticleRequest, options?: any): AxiosPromise<ShareArticleResponse> {
            return localVarFp.shareArticle(mock, shareArticleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SharedContentApi - object-oriented interface
 * @export
 * @class SharedContentApi
 * @extends {BaseAPI}
 */
export class SharedContentApi extends BaseAPI {
    /**
     * 
     * @summary Stop sharing article
     * @param {boolean} [mock] 
     * @param {DeleteSharedArticleRequest} [deleteSharedArticleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedContentApi
     */
    public deleteSharedArticle(mock?: boolean, deleteSharedArticleRequest?: DeleteSharedArticleRequest, options?: AxiosRequestConfig) {
        return SharedContentApiFp(this.configuration).deleteSharedArticle(mock, deleteSharedArticleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get article sharing status overview
     * @param {number} articleId 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedContentApi
     */
    public getArticleSharingStatusOverview(articleId: number, mock?: boolean, options?: AxiosRequestConfig) {
        return SharedContentApiFp(this.configuration).getArticleSharingStatusOverview(articleId, mock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share article
     * @param {boolean} [mock] 
     * @param {ShareArticleRequest} [shareArticleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedContentApi
     */
    public shareArticle(mock?: boolean, shareArticleRequest?: ShareArticleRequest, options?: AxiosRequestConfig) {
        return SharedContentApiFp(this.configuration).shareArticle(mock, shareArticleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SharingConnectionApi - axios parameter creator
 * @export
 */
export const SharingConnectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete single sharing connection
         * @param {number} connectionId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSharingConnection: async (connectionId: number, mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('deleteSharingConnection', 'connectionId', connectionId)
            const localVarPath = `/sharing/connection/{connectionId}`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get sharing connections
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharingConnection: async (mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sharing/connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create sharing connection
         * @param {boolean} [mock] 
         * @param {NewSharingConnection} [newSharingConnection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSharingConnection: async (mock?: boolean, newSharingConnection?: NewSharingConnection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sharing/connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newSharingConnection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharingConnectionApi - functional programming interface
 * @export
 */
export const SharingConnectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SharingConnectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete single sharing connection
         * @param {number} connectionId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSharingConnection(connectionId: number, mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSharingConnection(connectionId, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get sharing connections
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharingConnection(mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedTenants>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharingConnection(mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create sharing connection
         * @param {boolean} [mock] 
         * @param {NewSharingConnection} [newSharingConnection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSharingConnection(mock?: boolean, newSharingConnection?: NewSharingConnection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedSharingConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSharingConnection(mock, newSharingConnection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SharingConnectionApi - factory interface
 * @export
 */
export const SharingConnectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SharingConnectionApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete single sharing connection
         * @param {number} connectionId 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSharingConnection(connectionId: number, mock?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSharingConnection(connectionId, mock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get sharing connections
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharingConnection(mock?: boolean, options?: any): AxiosPromise<SharedTenants> {
            return localVarFp.getSharingConnection(mock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create sharing connection
         * @param {boolean} [mock] 
         * @param {NewSharingConnection} [newSharingConnection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSharingConnection(mock?: boolean, newSharingConnection?: NewSharingConnection, options?: any): AxiosPromise<CreatedSharingConnection> {
            return localVarFp.postSharingConnection(mock, newSharingConnection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SharingConnectionApi - object-oriented interface
 * @export
 * @class SharingConnectionApi
 * @extends {BaseAPI}
 */
export class SharingConnectionApi extends BaseAPI {
    /**
     * 
     * @summary Delete single sharing connection
     * @param {number} connectionId 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharingConnectionApi
     */
    public deleteSharingConnection(connectionId: number, mock?: boolean, options?: AxiosRequestConfig) {
        return SharingConnectionApiFp(this.configuration).deleteSharingConnection(connectionId, mock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get sharing connections
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharingConnectionApi
     */
    public getSharingConnection(mock?: boolean, options?: AxiosRequestConfig) {
        return SharingConnectionApiFp(this.configuration).getSharingConnection(mock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create sharing connection
     * @param {boolean} [mock] 
     * @param {NewSharingConnection} [newSharingConnection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharingConnectionApi
     */
    public postSharingConnection(mock?: boolean, newSharingConnection?: NewSharingConnection, options?: AxiosRequestConfig) {
        return SharingConnectionApiFp(this.configuration).postSharingConnection(mock, newSharingConnection, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UncompletedActionsApi - axios parameter creator
 * @export
 */
export const UncompletedActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get uncompleted actions for current user
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUncompletedActions: async (page?: number, perPage?: number, mock?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/uncompleted-actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (mock != null) {
                localVarHeaderParameter['mock'] = typeof mock === 'string' 
                    ? mock 
                    : JSON.stringify(mock);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UncompletedActionsApi - functional programming interface
 * @export
 */
export const UncompletedActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UncompletedActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get uncompleted actions for current user
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUncompletedActions(page?: number, perPage?: number, mock?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UncompletedActionsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUncompletedActions(page, perPage, mock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UncompletedActionsApi - factory interface
 * @export
 */
export const UncompletedActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UncompletedActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get uncompleted actions for current user
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {boolean} [mock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUncompletedActions(page?: number, perPage?: number, mock?: boolean, options?: any): AxiosPromise<UncompletedActionsPage> {
            return localVarFp.getUncompletedActions(page, perPage, mock, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UncompletedActionsApi - object-oriented interface
 * @export
 * @class UncompletedActionsApi
 * @extends {BaseAPI}
 */
export class UncompletedActionsApi extends BaseAPI {
    /**
     * 
     * @summary Get uncompleted actions for current user
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {boolean} [mock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UncompletedActionsApi
     */
    public getUncompletedActions(page?: number, perPage?: number, mock?: boolean, options?: AxiosRequestConfig) {
        return UncompletedActionsApiFp(this.configuration).getUncompletedActions(page, perPage, mock, options).then((request) => request(this.axios, this.basePath));
    }
}


